# 技術Q&A — 2026-02-27

### なぜ JPA ではなく MyBatis を使うのか？

JPA（Spring Data JPA + Hibernate）とMyBatisはどちらもJavaでDBアクセスするためのライブラリだが、哲学が大きく異なる。

**JPA の特徴**:
- SQLを自動生成してくれる（`findByFitbitUserId` と書くだけでSELECT文が生成される）
- `@Entity`, `@OneToOne` などのアノテーションで関連を宣言するだけでJOINも自動
- 裏でどんなSQLが発行されているかがわかりにくい（N+1問題など罠もある）

**MyBatis の特徴**:
- SQLを自分で書く（XML ファイルにSQLを定義する）
- どんなクエリが発行されるかが常に明確で、チューニングしやすい
- SQLを直接学べるため、DBの学習に向いている
- JPA より設定が少なく、シンプルな構成になる

**今回の選択理由**: ユーザーの学習目的のため、SQLを明示的に書くMyBatisを採用する。SQLの書き方・仕組みを習得しながら実装を進められる。

### MyBatis の基本的な仕組みは？

MyBatis は以下の3要素で成り立つ:

1. **Mapper インターフェース** — DB操作のメソッドを定義する Java インターフェース
   ```java
   @Mapper
   public interface UserMapper {
       Optional<User> findByFitbitUserId(String fitbitUserId);
   }
   ```

2. **Mapper XML** — 各メソッドに対応するSQLを定義するXMLファイル
   ```xml
   <select id="findByFitbitUserId" resultMap="UserResultMap">
       SELECT * FROM users WHERE fitbit_user_id = #{fitbitUserId}
   </select>
   ```

3. **POJO（Plain Old Java Object）** — DBの1行を表す普通のJavaクラス（アノテーション不要）

MyBatisは `namespace`（インターフェースの完全クラス名）でインターフェースとXMLを紐付けて動作する。

### JPA の POJO との違いは？

| 観点 | JPA エンティティ | MyBatis POJO |
|------|----------------|--------------|
| アノテーション | `@Entity`, `@Table`, `@Column`, `@OneToOne` など多数 | なし（Lombokのみ） |
| テーブルとの対応 | アノテーションで宣言 | XMLの `<resultMap>` で定義 |
| テーブル間の関連 | `@OneToOne`, `@ManyToOne` など | XMLの `<association>` や独自SQLで表現 |
| タイムスタンプ | `@CreationTimestamp` で自動管理 | SQLの `NOW()` で明示的にセット |

### `map-underscore-to-camel-case: true` とは？

DBのカラム名（スネークケース: `fitbit_user_id`）をJavaのフィールド名（キャメルケース: `fitbitUserId`）に自動変換してくれる設定。
これにより、`<resultMap>` で全フィールドを手動マッピングしなくても、単純なカラムは自動的にマッピングされる。
ただし、UUID 型など型変換が必要なフィールドは `<resultMap>` で明示的に定義する必要がある。

### Lombok とは何か？なぜ使うのか？

Javaは定型コード（ボイラープレート）が多い言語で、getter・コンストラクタ・Builder などを手書きすると非常に長くなる。
Lombok はアノテーションを付けるだけでこれらを自動生成してくれるライブラリ。

```java
// Lombok なし → getter・コンストラクタ・Builder をすべて手書きする必要がある
// Lombok あり → アノテーション3つで済む
@Getter
@NoArgsConstructor
@Builder
public class User { ... }
```

主要アノテーション:

| アノテーション | 生成されるもの |
|--------------|-------------|
| `@Getter` | 全フィールドの `getXxx()` メソッド |
| `@NoArgsConstructor` | 引数なしコンストラクタ `User()` |
| `@AllArgsConstructor` | 全フィールドを引数に取るコンストラクタ |
| `@Builder` | ビルダーパターン（`User.builder().xxx().build()`） |
| `@Setter` | 全フィールドの `setXxx()` メソッド |

### MyBatis はなぜ `@NoArgsConstructor`（引数なしコンストラクタ）が必要なのか？

MyBatis がDBから取得した値をJavaオブジェクトに詰め替える際の動作手順:

```
1. new User()         ← 引数なしコンストラクタでまず空のオブジェクトを生成
2. user.fitbitUserId = "ABC123"  ← リフレクションで各フィールドに直接値をセット
3. user.displayName  = "田中太郎"
...
```

`@NoArgsConstructor` がないと手順1で `new User()` が呼べずエラーになる。

MyBatis は全引数コンストラクタ（`@AllArgsConstructor`）を使う方法もあるが、その場合は XML に `<constructor>` タグで全フィールドのマッピングを明示する必要があり、設定が冗長になる。引数なしコンストラクタ + リフレクション方式の方がシンプルで一般的。

### なぜ `@Setter` がなくても MyBatis はフィールドに値をセットできるのか？

MyBatis はリフレクションの `setAccessible(true)` を使い、private フィールドに直接書き込む。

```java
// MyBatis が内部でやっていること（イメージ）
Field field = User.class.getDeclaredField("fitbitUserId");
field.setAccessible(true);    // private でも強制的にアクセス可能にする
field.set(userObject, "ABC123");  // 直接書き込む
```

Setter メソッドを経由しないため `@Setter` は不要。
また、`@Setter` を付けないことで「外部から自由にフィールドを書き換えられない」という設計上のメリットもある（意図的な変更は `updateProfile()` のような専用メソッド経由に限定できる）。

### `User.builder()` はどういう挙動をするのか？

`@Builder` は以下のような静的内部クラスを自動生成する。

```java
// @Builder が自動生成するコード（イメージ）
public class User {
    // ① builder() を呼ぶと Builder オブジェクトが返る
    public static UserBuilder builder() {
        return new UserBuilder();
    }

    public static class UserBuilder {
        private UUID id;
        private String fitbitUserId;
        // ...（User と同じフィールド）

        // ② 各フィールドのセットメソッド（自分自身を返すのでチェーンできる）
        public UserBuilder fitbitUserId(String fitbitUserId) {
            this.fitbitUserId = fitbitUserId;
            return this;  // ← this を返すのでドットでつなげて書ける
        }

        // ③ build() で User オブジェクトを組み立てて返す
        public User build() {
            return new User(id, fitbitUserId, ...);
        }
    }
}
```

実際の使い方:

```java
User user = User.builder()
    .fitbitUserId("ABC123")
    .displayName("田中太郎")
    .build();
```

Builder パターンのメリットは、引数が多いコンストラクタで「どの値が何番目か」を気にせず、フィールド名を書きながら値を渡せること。

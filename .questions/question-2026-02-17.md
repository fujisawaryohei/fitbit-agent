# 技術Q&A: 2026-02-17

### VS Code で Javadoc をプレビューする方法

3つの方法がある。

1. **ホバー表示（最も手軽）**: コード上のクラス名・メソッド名にカーソルを乗せると Javadoc がポップアップ表示される。Extension Pack for Java が必要。

2. **HTML生成してブラウザ表示**: `cd backend && mvn javadoc:javadoc` で `target/site/apidocs/index.html` を生成。VS Code の Live Preview 拡張機能（Microsoft製）を使うとエディタ内ブラウザで表示できる。

3. **`/** */` 形式のコメントを書いておく**: ホバー時の表示が充実する。`@param`、`@return` タグで引数・戻り値の説明を書く形式。

普段使いにはホバー表示（方法1）が最も手軽。

### OAuth2.0 認可コードフローとは何か

Fitbit ログインに使う「認可コードフロー」の流れ:

1. **ログイン開始**: サーバーが Fitbit 認可URL（state パラメータ付き）を生成してリダイレクト
2. **同意画面**: Fitbit 側でユーザーが「許可する」を押す
3. **コールバック**: Fitbit がブラウザを `?code=xxx&state=yyy` 付きでサーバーにリダイレクト
4. **トークン交換**: サーバーが Fitbit の `/oauth2/token` に POST して認可コード → アクセストークンに交換
5. **保存**: トークンを AES-256-GCM で暗号化して DB に保存、セッション生成

主なキーワード:
- **認可コード**: 数分で失効する使い捨ての通行証。トークンと交換するためだけに使う
- **アクセストークン**: Fitbit API を叩くための鍵（有効期限8時間）
- **リフレッシュトークン**: アクセストークンを更新するための鍵
- **state パラメータ**: CSRF対策。ログイン開始時に生成してコールバック時に照合する

Spring Security の OAuth2 Client 自動設定は使わず手動実装する理由: Fitbit はトークンエンドポイントで Basic 認証ヘッダーが必要など独自仕様があるため、WebClient で直接 POST する。

### なぜ実装順序が Enum → Entity → Repository → Service → Controller の順になるのか

Javaでは参照先のクラスが存在しないとコンパイルエラーになるため、**依存される側から先に作る**必要がある。

依存関係の方向:
```
Enum（依存なし）→ Entity（Enumを参照）→ Repository（Entityを参照）→ Service（Repositoryを参照）→ Controller（Serviceを参照）
```

これはレイヤードアーキテクチャの依存ルール（下位レイヤーから上位レイヤーへ順に作る）とも一致している。また、Enum のような単純なクラスを先に作ることで、複雑なクラスを書く前のウォームアップにもなる。

### Flyway マイグレーションファイルの SQL 構文の意味

以下は `V1__create_users.sql` の各要素の解説。

- `CREATE TABLE users (...)` — テーブルを作成する SQL 文。`users` がテーブル名。
- `id UUID PRIMARY KEY DEFAULT gen_random_uuid()` — 主キー定義。`UUID` は一意な識別子の型（例: `550e8400-e29b-41d4-a716-446655440000`）。`PRIMARY KEY` はこのカラムがテーブル内で一意であることを保証する。`DEFAULT gen_random_uuid()` はレコード挿入時に値を指定しなければ PostgreSQL が自動で UUID を生成する。
- `VARCHAR(64)` — 可変長文字列型。括弧内の数字が保持できる最大文字数。`VARCHAR(64)` なら最大64文字。
- `NOT NULL` — このカラムに空（NULL）を許可しない制約。設計書で「NULL: NO」のカラムに付ける。省略すると NULL が許可される。
- `DECIMAL(5,1)` — 固定精度の数値型。第1引数が全体の桁数、第2引数が小数点以下の桁数。`DECIMAL(5,1)` は最大 `9999.9`（例: `170.5`）。`DECIMAL(5,2)` なら最大 `999.99`（例: `72.30`）。
- `DEFAULT CURRENT_TIMESTAMP` — レコード挿入時に現在の日時が自動セットされる。`created_at` や `updated_at` のように「いつ作られたか」を記録するカラムで使う。
- `CONSTRAINT uk_users_fitbit_user_id UNIQUE (fitbit_user_id)` — ユニーク制約。`fitbit_user_id` カラムの値がテーブル内で重複しないことを保証する。`CONSTRAINT` の後の名前（`uk_users_fitbit_user_id`）は制約の識別名で、エラーメッセージ等に表示される。命名規則は `uk_{テーブル}_{カラム}`。

### FOREIGN KEY（外部キー）とは何か

他のテーブルの主キーを参照する制約。`FOREIGN KEY (user_id) REFERENCES users(id)` と書くと、「user_id カラムの値は users テーブルの id カラムに存在する値でなければならない」というルールが適用される。存在しない user_id を挿入しようとするとエラーになる。

`ON DELETE CASCADE` を付けると、親レコード（users）が削除された時に子レコード（例: oauth_tokens）も自動的に削除される。付けない場合、子レコードが存在する親レコードは削除できない。

### UNIQUE 制約と INDEX の違い

- `UNIQUE` 制約 — カラムの値の重複を禁止するルール。PostgreSQL では UNIQUE 制約を作ると内部的にインデックスも自動作成される。
- `CREATE INDEX` — 検索を高速化するためのデータ構造。重複は許可する（UNIQUE を付けない限り）。

つまり `CONSTRAINT uk_xxx UNIQUE (col1, col2)` を書けば、重複禁止 + 検索高速化の両方が得られる。`goals` テーブルのように重複を許可しつつ検索を速くしたい場合は `CREATE INDEX` のみを使う。

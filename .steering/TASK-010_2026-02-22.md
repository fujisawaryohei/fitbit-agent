# TASK-010: Fitbit OAuth2.0 ログイン（バックエンド）

## 概要
Spring Security + OAuth2 Client で Fitbit OAuth2.0 認証を実装する。
ユーザーが Fitbit アカウントでログインし、アクセストークンを暗号化してDBに保存する。

## 受入条件
- [ ] `GET /api/auth/login` でFitbit認可URLにリダイレクトされる
- [ ] `GET /api/auth/callback` でトークン取得・暗号化保存・セッション生成が行われる
- [ ] トークン自動リフレッシュが動作する

## 参照ドキュメント
- OAuth2.0フロー: docs/basic-functional-design.md セクション6.2
- セキュリティ設計: docs/architecture.md セクション6
- パッケージ構成: docs/architecture.md セクション3.2

## 事前確認（着手前に必要）
- Fitbit Developer Console でアプリを登録し、以下を取得する必要がある
  - `FITBIT_CLIENT_ID`
  - `FITBIT_CLIENT_SECRET`
  - Callback URL: `http://localhost:8080/api/auth/callback`

## 作業手順

- [x] Step 1: Enum 作成（GoalType / AdviceType / ChatRole）
- [ ] Step 2: User エンティティ作成
- [ ] Step 3: OAuthToken エンティティ作成
- [ ] Step 4: UserRepository / OAuthTokenRepository 作成
- [ ] Step 5: TokenEncryptionService 作成（AES-256-GCM）
- [ ] Step 6: FitbitConfig 作成
- [ ] Step 7: application-dev.yml に Fitbit OAuth2 設定追加
- [ ] Step 8: SecurityConfig 作成
- [ ] Step 9: FitbitOAuthClient 作成（トークン交換・リフレッシュ）
- [ ] Step 10: AuthService 作成
- [ ] Step 11: AuthController 作成
- [ ] Step 12: WebConfig 作成（CORS設定）
- [ ] Step 13: GlobalExceptionHandler 作成
- [ ] Step 14: 動作確認

---

## Step 1: Enum 作成

後続タスクでも使う列挙型を先に作成する。

### GoalType.java
**ファイルパス**: `backend/src/main/java/com/fitbitagent/domain/enums/GoalType.java`

目標の種別を表す。goals テーブルの `goal_type` カラムの値に対応する。

```java
package com.fitbitagent.domain.enums;

public enum GoalType {
    WEIGHT,
    STEPS,
    CALORIES_BURNED,
    CALORIES_INTAKE
}
```

### AdviceType.java
**ファイルパス**: `backend/src/main/java/com/fitbitagent/domain/enums/AdviceType.java`

```java
package com.fitbitagent.domain.enums;

public enum AdviceType {
    DAILY,
    WEEKLY
}
```

### ChatRole.java
**ファイルパス**: `backend/src/main/java/com/fitbitagent/domain/enums/ChatRole.java`

```java
package com.fitbitagent.domain.enums;

public enum ChatRole {
    USER,
    ASSISTANT
}
```

---

## Step 2: User POJO 作成

**ファイルパス**: `backend/src/main/java/com/fitbitagent/domain/entity/User.java`

MyBatis では JPA のような `@Entity` アノテーションは不要。DBのテーブル1行を表す普通のJavaクラス（POJO）として作成する。
Lombok の `@Getter` / `@Builder` / `@NoArgsConstructor` だけ使用する。

```java
package com.fitbitagent.domain.entity;

import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.UUID;

@Getter
@NoArgsConstructor
@Builder
public class User {

    private UUID id;
    private String fitbitUserId;
    private String displayName;
    private String gender;
    private BigDecimal heightCm;
    private LocalDate dateOfBirth;
    private String activityLevel;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;

    // 既存ユーザーのプロフィール更新用メソッド
    public void updateProfile(String displayName, String gender, BigDecimal heightCm,
                              LocalDate dateOfBirth, String activityLevel) {
        this.displayName = displayName;
        this.gender = gender;
        this.heightCm = heightCm;
        this.dateOfBirth = dateOfBirth;
        this.activityLevel = activityLevel;
    }
}
```

**ポイント**:
- JPA アノテーション（`@Entity`, `@Table`, `@Column` 等）は一切不要
- フィールド名は `map-underscore-to-camel-case: true` の設定により、DBカラム名（`fitbit_user_id`）と自動的にマッピングされる
- `@Getter` / `@NoArgsConstructor` / `@Builder` — Lombokで定型コードを自動生成

---

## Step 3: OAuthToken POJO 作成

**ファイルパス**: `backend/src/main/java/com/fitbitagent/domain/entity/OAuthToken.java`

User と同様に、JPA アノテーションなしの POJO として作成する。
User との関連（1:1）は `@OneToOne` ではなく、後の Mapper XML の `<association>` タグで表現する。

```java
package com.fitbitagent.domain.entity;

import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;
import java.util.UUID;

@Getter
@NoArgsConstructor
@Builder
public class OAuthToken {

    private UUID id;
    private UUID userId;
    private String accessToken;
    private String refreshToken;
    private LocalDateTime expiresAt;
    private String scope;

    // トークン更新用メソッド
    public void updateTokens(String accessToken, String refreshToken, LocalDateTime expiresAt) {
        this.accessToken = accessToken;
        this.refreshToken = refreshToken;
        this.expiresAt = expiresAt;
    }

    public boolean isExpired() {
        return LocalDateTime.now().isAfter(expiresAt.minusMinutes(5));
    }
}
```

**ポイント**:
- User との関連は `userId` フィールド（外部キーの値）で保持する
- JPA の `@OneToOne` のような自動JOINはなく、必要な場合は Mapper XML で明示的にSQLを書く

---

## Step 4: Mapper インターフェース + XML 作成

MyBatis の Mapper は「インターフェース + XML でSQL操作を定義する」仕組み。
JPA の `JpaRepository` と異なり、SQLを自分で書く必要があるが、その分挙動が明確でデバッグしやすい。

### UserMapper.java
**ファイルパス**: `backend/src/main/java/com/fitbitagent/repository/UserMapper.java`

```java
package com.fitbitagent.repository;

import com.fitbitagent.domain.entity.User;
import org.apache.ibatis.annotations.Mapper;

import java.util.Optional;
import java.util.UUID;

@Mapper
public interface UserMapper {
    Optional<User> findById(UUID id);
    Optional<User> findByFitbitUserId(String fitbitUserId);
    void insert(User user);
    void update(User user);
}
```

### OAuthTokenMapper.java
**ファイルパス**: `backend/src/main/java/com/fitbitagent/repository/OAuthTokenMapper.java`

```java
package com.fitbitagent.repository;

import com.fitbitagent.domain.entity.OAuthToken;
import org.apache.ibatis.annotations.Mapper;

import java.util.Optional;
import java.util.UUID;

@Mapper
public interface OAuthTokenMapper {
    Optional<OAuthToken> findByUserId(UUID userId);
    void insert(OAuthToken oAuthToken);
    void update(OAuthToken oAuthToken);
}
```

### UserMapper.xml
**ファイルパス**: `backend/src/main/resources/mybatis/mapper/UserMapper.xml`

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">

<mapper namespace="com.fitbitagent.repository.UserMapper">

    <resultMap id="UserResultMap" type="com.fitbitagent.domain.entity.User">
        <id property="id" column="id" javaType="java.util.UUID"/>
        <result property="fitbitUserId" column="fitbit_user_id"/>
        <result property="displayName" column="display_name"/>
        <result property="gender" column="gender"/>
        <result property="heightCm" column="height_cm"/>
        <result property="dateOfBirth" column="date_of_birth"/>
        <result property="activityLevel" column="activity_level"/>
        <result property="createdAt" column="created_at"/>
        <result property="updatedAt" column="updated_at"/>
    </resultMap>

    <select id="findById" parameterType="java.util.UUID" resultMap="UserResultMap">
        SELECT * FROM users WHERE id = #{id}
    </select>

    <select id="findByFitbitUserId" parameterType="String" resultMap="UserResultMap">
        SELECT * FROM users WHERE fitbit_user_id = #{fitbitUserId}
    </select>

    <insert id="insert" parameterType="com.fitbitagent.domain.entity.User">
        INSERT INTO users (id, fitbit_user_id, display_name, gender, height_cm, date_of_birth, activity_level, created_at, updated_at)
        VALUES (#{id}, #{fitbitUserId}, #{displayName}, #{gender}, #{heightCm}, #{dateOfBirth}, #{activityLevel}, NOW(), NOW())
    </insert>

    <update id="update" parameterType="com.fitbitagent.domain.entity.User">
        UPDATE users
        SET display_name   = #{displayName},
            gender         = #{gender},
            height_cm      = #{heightCm},
            date_of_birth  = #{dateOfBirth},
            activity_level = #{activityLevel},
            updated_at     = NOW()
        WHERE id = #{id}
    </update>

</mapper>
```

### OAuthTokenMapper.xml
**ファイルパス**: `backend/src/main/resources/mybatis/mapper/OAuthTokenMapper.xml`

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">

<mapper namespace="com.fitbitagent.repository.OAuthTokenMapper">

    <resultMap id="OAuthTokenResultMap" type="com.fitbitagent.domain.entity.OAuthToken">
        <id property="id" column="id" javaType="java.util.UUID"/>
        <result property="userId" column="user_id" javaType="java.util.UUID"/>
        <result property="accessToken" column="access_token"/>
        <result property="refreshToken" column="refresh_token"/>
        <result property="expiresAt" column="expires_at"/>
        <result property="scope" column="scope"/>
    </resultMap>

    <select id="findByUserId" parameterType="java.util.UUID" resultMap="OAuthTokenResultMap">
        SELECT * FROM oauth_tokens WHERE user_id = #{userId}
    </select>

    <insert id="insert" parameterType="com.fitbitagent.domain.entity.OAuthToken">
        INSERT INTO oauth_tokens (id, user_id, access_token, refresh_token, expires_at, scope)
        VALUES (#{id}, #{userId}, #{accessToken}, #{refreshToken}, #{expiresAt}, #{scope})
    </insert>

    <update id="update" parameterType="com.fitbitagent.domain.entity.OAuthToken">
        UPDATE oauth_tokens
        SET access_token  = #{accessToken},
            refresh_token = #{refreshToken},
            expires_at    = #{expiresAt}
        WHERE user_id = #{userId}
    </update>

</mapper>
```

**ポイント**:
- `@Mapper` — MyBatis がこのインターフェースの実装を自動生成することを示す
- Mapper XML の `namespace` はインターフェースの完全クラス名と一致させる必要がある
- `<resultMap>` — DBのカラム名とJavaのフィールド名のマッピングを定義する
- SQLは自分で書くため、どんなクエリが発行されるかが常に明確

---

## Step 4.5: MyBatisConfig 作成

**ファイルパス**: `backend/src/main/java/com/fitbitagent/config/MyBatisConfig.java`

Mapper インターフェースをスキャンする設定クラス。旧 JpaConfig の代わり。

```java
package com.fitbitagent.config;

import org.mybatis.spring.annotation.MapperScan;
import org.springframework.context.annotation.Configuration;

@Configuration
@MapperScan("com.fitbitagent.repository")
public class MyBatisConfig {
}
```

**ポイント**:
- `@MapperScan` — 指定パッケージ内の `@Mapper` インターフェースをすべてスキャンし、Spring Bean として登録する

---

## Step 5: TokenEncryptionService 作成

**ファイルパス**: `backend/src/main/java/com/fitbitagent/service/TokenEncryptionService.java`

Fitbit のアクセストークン・リフレッシュトークンを AES-256-GCM で暗号化してDBに保存する。
（暗号化しないと、DB流出時にトークンが悪用されるリスクがある）

```java
package com.fitbitagent.service;

import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;

import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.spec.GCMParameterSpec;
import javax.crypto.spec.SecretKeySpec;
import java.security.SecureRandom;
import java.util.Base64;

@Service
@Slf4j
public class TokenEncryptionService {

    private static final String ALGORITHM = "AES/GCM/NoPadding";
    private static final int GCM_IV_LENGTH = 12;
    private static final int GCM_TAG_LENGTH = 128;

    private final SecretKey secretKey;

    public TokenEncryptionService(@Value("${app.token-encryption-key}") String base64Key) {
        byte[] keyBytes = Base64.getDecoder().decode(base64Key);
        this.secretKey = new SecretKeySpec(keyBytes, "AES");
    }

    public String encrypt(String plainText) {
        try {
            byte[] iv = new byte[GCM_IV_LENGTH];
            new SecureRandom().nextBytes(iv);

            Cipher cipher = Cipher.getInstance(ALGORITHM);
            cipher.init(Cipher.ENCRYPT_MODE, secretKey, new GCMParameterSpec(GCM_TAG_LENGTH, iv));

            byte[] encrypted = cipher.doFinal(plainText.getBytes());
            byte[] combined = new byte[iv.length + encrypted.length];
            System.arraycopy(iv, 0, combined, 0, iv.length);
            System.arraycopy(encrypted, 0, combined, iv.length, encrypted.length);

            return Base64.getEncoder().encodeToString(combined);
        } catch (Exception e) {
            throw new RuntimeException("Token encryption failed", e);
        }
    }

    public String decrypt(String encryptedText) {
        try {
            byte[] combined = Base64.getDecoder().decode(encryptedText);
            byte[] iv = new byte[GCM_IV_LENGTH];
            System.arraycopy(combined, 0, iv, 0, iv.length);
            byte[] encrypted = new byte[combined.length - iv.length];
            System.arraycopy(combined, iv.length, encrypted, 0, encrypted.length);

            Cipher cipher = Cipher.getInstance(ALGORITHM);
            cipher.init(Cipher.DECRYPT_MODE, secretKey, new GCMParameterSpec(GCM_TAG_LENGTH, iv));

            return new String(cipher.doFinal(encrypted));
        } catch (Exception e) {
            throw new RuntimeException("Token decryption failed", e);
        }
    }
}
```

**設定が必要**: `application-dev.yml` に `app.token-encryption-key` を追加する（Step 7で行う）。
暗号化キーは Base64 エンコードされた 32バイト（256bit）のランダム文字列。

開発用キーの生成コマンド:
```bash
openssl rand -base64 32
```

---

## Step 6: FitbitConfig 作成

**ファイルパス**: `backend/src/main/java/com/fitbitagent/config/FitbitConfig.java`

`application.yml` の設定値を Java クラスとして読み込む。

```java
package com.fitbitagent.config;

import lombok.Getter;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Configuration;

@Configuration
@Getter
public class FitbitConfig {

    @Value("${fitbit.client-id}")
    private String clientId;

    @Value("${fitbit.client-secret}")
    private String clientSecret;

    @Value("${fitbit.redirect-uri}")
    private String redirectUri;

    @Value("${fitbit.authorization-uri:https://www.fitbit.com/oauth2/authorize}")
    private String authorizationUri;

    @Value("${fitbit.token-uri:https://api.fitbit.com/oauth2/token}")
    private String tokenUri;

    @Value("${fitbit.api-base-url:https://api.fitbit.com}")
    private String apiBaseUrl;

    @Value("${fitbit.scope:activity heartrate location nutrition profile settings sleep social weight}")
    private String scope;
}
```

---

## Step 7: application-dev.yml に設定追加

**ファイルパス**: `backend/src/main/resources/application-dev.yml`

以下を追記する:

```yaml
fitbit:
  client-id: ${FITBIT_CLIENT_ID}
  client-secret: ${FITBIT_CLIENT_SECRET}
  redirect-uri: http://localhost:8080/api/auth/callback

app:
  token-encryption-key: ${TOKEN_ENCRYPTION_KEY}
```

**環境変数の設定方法**（ターミナルで実行）:
```bash
# 暗号化キーを生成して設定
export TOKEN_ENCRYPTION_KEY=$(openssl rand -base64 32)
export FITBIT_CLIENT_ID=your_client_id
export FITBIT_CLIENT_SECRET=your_client_secret
```

または `docker/.env` に追記して管理してもよい。

---

## Step 8: SecurityConfig 作成

**ファイルパス**: `backend/src/main/java/com/fitbitagent/config/SecurityConfig.java`

Spring Security の設定。どのエンドポイントを保護するか、CSRFの扱いなどを定義する。

```java
package com.fitbitagent.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.csrf.CookieCsrfTokenRepository;

@Configuration
@EnableWebSecurity
public class SecurityConfig {

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/api/auth/login", "/api/auth/callback").permitAll()
                .anyRequest().authenticated()
            )
            .csrf(csrf -> csrf
                .csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse())
                .ignoringRequestMatchers("/api/auth/callback")
            )
            .sessionManagement(session -> session
                .maximumSessions(1)
            );

        return http.build();
    }
}
```

**ポイント**:
- `permitAll()` — `/api/auth/login` と `/api/auth/callback` は未認証でもアクセス可能にする
- `anyRequest().authenticated()` — それ以外は認証必須
- `CookieCsrfTokenRepository` — CSRFトークンをCookieで管理（フロントエンドから送信可能にするため `HttpOnlyFalse`）
- `/api/auth/callback` は Fitbit からのリダイレクトなので CSRF チェック対象外にする

---

## Step 9: FitbitOAuthClient 作成

**ファイルパス**: `backend/src/main/java/com/fitbitagent/client/fitbit/FitbitOAuthClient.java`

Fitbit の OAuth2.0 エンドポイントと通信する。認可コード → トークン交換とトークンリフレッシュを担当。

```java
package com.fitbitagent.client.fitbit;

import com.fitbitagent.config.FitbitConfig;
import com.fitbitagent.exception.FitbitApiException;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;
import org.springframework.util.LinkedMultiValueMap;
import org.springframework.util.MultiValueMap;
import org.springframework.web.reactive.function.BodyInserters;
import org.springframework.web.reactive.function.client.WebClient;

import java.util.Map;

@Component
@RequiredArgsConstructor
@Slf4j
public class FitbitOAuthClient {

    private final FitbitConfig fitbitConfig;
    private final WebClient webClient;

    // 認可コードをアクセストークンに交換する
    public Map<String, Object> exchangeCodeForToken(String code) {
        MultiValueMap<String, String> body = new LinkedMultiValueMap<>();
        body.add("grant_type", "authorization_code");
        body.add("code", code);
        body.add("redirect_uri", fitbitConfig.getRedirectUri());

        return callTokenEndpoint(body);
    }

    // リフレッシュトークンで新しいアクセストークンを取得する
    public Map<String, Object> refreshToken(String refreshToken) {
        MultiValueMap<String, String> body = new LinkedMultiValueMap<>();
        body.add("grant_type", "refresh_token");
        body.add("refresh_token", refreshToken);

        return callTokenEndpoint(body);
    }

    @SuppressWarnings("unchecked")
    private Map<String, Object> callTokenEndpoint(MultiValueMap<String, String> body) {
        try {
            return webClient.post()
                    .uri(fitbitConfig.getTokenUri())
                    .headers(headers -> headers.setBasicAuth(
                            fitbitConfig.getClientId(),
                            fitbitConfig.getClientSecret()))
                    .body(BodyInserters.fromFormData(body))
                    .retrieve()
                    .bodyToMono(Map.class)
                    .block();
        } catch (Exception e) {
            log.error("Failed to call Fitbit token endpoint", e);
            throw new FitbitApiException("Failed to obtain token from Fitbit", e);
        }
    }
}
```

**WebBean の登録も必要**。`SecurityConfig.java` か新しい Config クラスに以下を追加:

```java
@Bean
public WebClient webClient() {
    return WebClient.builder()
            .defaultHeader("Content-Type", "application/x-www-form-urlencoded")
            .build();
}
```

---

## Step 10: 例外クラス作成

`FitbitOAuthClient` で使う例外クラスを先に作る。

### FitbitApiException.java
**ファイルパス**: `backend/src/main/java/com/fitbitagent/exception/FitbitApiException.java`

```java
package com.fitbitagent.exception;

public class FitbitApiException extends RuntimeException {
    public FitbitApiException(String message) {
        super(message);
    }
    public FitbitApiException(String message, Throwable cause) {
        super(message, cause);
    }
}
```

---

## Step 11: AuthService 作成

**ファイルパス**: `backend/src/main/java/com/fitbitagent/service/AuthService.java`

OAuth2.0 コールバック処理のビジネスロジック。トークン交換 → ユーザー作成/更新 → セッション生成を行う。

```java
package com.fitbitagent.service;

import com.fitbitagent.client.fitbit.FitbitOAuthClient;
import com.fitbitagent.config.FitbitConfig;
import com.fitbitagent.domain.entity.OAuthToken;
import com.fitbitagent.domain.entity.User;
import com.fitbitagent.repository.OAuthTokenRepository;
import com.fitbitagent.repository.UserRepository;
import jakarta.servlet.http.HttpSession;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.util.UriComponentsBuilder;

import java.time.LocalDateTime;
import java.util.Map;
import java.util.UUID;

@Service
@RequiredArgsConstructor
@Slf4j
public class AuthService {

    private final FitbitConfig fitbitConfig;
    private final FitbitOAuthClient fitbitOAuthClient;
    private final UserRepository userRepository;
    private final OAuthTokenRepository oAuthTokenRepository;
    private final TokenEncryptionService tokenEncryptionService;

    // Fitbit 認可URLを生成する
    public String buildAuthorizationUrl(String state) {
        return UriComponentsBuilder.fromHttpUrl(fitbitConfig.getAuthorizationUri())
                .queryParam("response_type", "code")
                .queryParam("client_id", fitbitConfig.getClientId())
                .queryParam("redirect_uri", fitbitConfig.getRedirectUri())
                .queryParam("scope", fitbitConfig.getScope())
                .queryParam("state", state)
                .toUriString();
    }

    // コールバック処理: トークン取得 → ユーザー保存 → セッション生成
    @Transactional
    public User handleCallback(String code, HttpSession session) {
        // 1. 認可コード → トークン交換
        Map<String, Object> tokenResponse = fitbitOAuthClient.exchangeCodeForToken(code);

        String accessToken = (String) tokenResponse.get("access_token");
        String refreshToken = (String) tokenResponse.get("refresh_token");
        Integer expiresIn = (Integer) tokenResponse.get("expires_in");
        String userId = (String) tokenResponse.get("user_id");
        String scope = (String) tokenResponse.get("scope");

        LocalDateTime expiresAt = LocalDateTime.now().plusSeconds(expiresIn);

        // 2. ユーザーを取得または新規作成
        User user = userRepository.findByFitbitUserId(userId)
                .orElseGet(() -> userRepository.save(
                        User.builder()
                                .fitbitUserId(userId)
                                .build()
                ));

        // 3. トークンを暗号化してDBに保存（UPSERT）
        String encryptedAccess = tokenEncryptionService.encrypt(accessToken);
        String encryptedRefresh = tokenEncryptionService.encrypt(refreshToken);

        oAuthTokenRepository.findByUser(user)
                .ifPresentOrElse(
                        token -> token.updateTokens(encryptedAccess, encryptedRefresh, expiresAt),
                        () -> oAuthTokenRepository.save(OAuthToken.builder()
                                .user(user)
                                .accessToken(encryptedAccess)
                                .refreshToken(encryptedRefresh)
                                .expiresAt(expiresAt)
                                .scope(scope)
                                .build())
                );

        // 4. セッションにユーザーIDを保存
        session.setAttribute("userId", user.getId());
        log.info("User logged in: {}", user.getId());

        return user;
    }

    // トークンリフレッシュ
    @Transactional
    public void refreshToken(User user) {
        OAuthToken token = oAuthTokenRepository.findByUser(user)
                .orElseThrow(() -> new RuntimeException("Token not found for user: " + user.getId()));

        String decryptedRefreshToken = tokenEncryptionService.decrypt(token.getRefreshToken());
        Map<String, Object> tokenResponse = fitbitOAuthClient.refreshToken(decryptedRefreshToken);

        String newAccessToken = (String) tokenResponse.get("access_token");
        String newRefreshToken = (String) tokenResponse.get("refresh_token");
        Integer expiresIn = (Integer) tokenResponse.get("expires_in");

        token.updateTokens(
                tokenEncryptionService.encrypt(newAccessToken),
                tokenEncryptionService.encrypt(newRefreshToken),
                LocalDateTime.now().plusSeconds(expiresIn)
        );
    }
}
```

---

## Step 12: AuthController 作成

**ファイルパス**: `backend/src/main/java/com/fitbitagent/controller/AuthController.java`

```java
package com.fitbitagent.controller;

import com.fitbitagent.service.AuthService;
import jakarta.servlet.http.HttpSession;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.servlet.view.RedirectView;

import java.util.UUID;

@RestController
@RequestMapping("/api/auth")
@RequiredArgsConstructor
@Slf4j
public class AuthController {

    private final AuthService authService;

    // ログイン: Fitbit 認可URLへリダイレクト
    @GetMapping("/login")
    public RedirectView login(HttpSession session) {
        String state = UUID.randomUUID().toString();
        session.setAttribute("oauth_state", state);
        String authorizationUrl = authService.buildAuthorizationUrl(state);
        return new RedirectView(authorizationUrl);
    }

    // コールバック: Fitbit から認可コードを受け取る
    @GetMapping("/callback")
    public RedirectView callback(@RequestParam String code,
                                  @RequestParam String state,
                                  HttpSession session) {
        // state 検証（CSRF対策）
        String savedState = (String) session.getAttribute("oauth_state");
        if (!state.equals(savedState)) {
            log.warn("OAuth state mismatch. Expected: {}, Got: {}", savedState, state);
            return new RedirectView("/login?error=invalid_state");
        }

        authService.handleCallback(code, session);
        return new RedirectView("/dashboard");
    }

    // ログアウト
    @PostMapping("/logout")
    @ResponseStatus(HttpStatus.NO_CONTENT)
    public void logout(HttpSession session) {
        session.invalidate();
    }
}
```

---

## Step 13: WebConfig 作成（CORS設定）

**ファイルパス**: `backend/src/main/java/com/fitbitagent/config/WebConfig.java`

フロントエンド（localhost:5173）からのリクエストを許可する。

```java
package com.fitbitagent.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.CorsRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class WebConfig implements WebMvcConfigurer {

    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/api/**")
                .allowedOrigins("http://localhost:5173")
                .allowedMethods("GET", "POST", "PUT", "DELETE")
                .allowedHeaders("Content-Type", "X-CSRF-TOKEN")
                .allowCredentials(true);
    }
}
```

---

## Step 14: 動作確認

1. 環境変数を設定して Spring Boot を起動:
```bash
export TOKEN_ENCRYPTION_KEY=$(openssl rand -base64 32)
export FITBIT_CLIENT_ID=your_client_id
export FITBIT_CLIENT_SECRET=your_client_secret
cd backend && mvn spring-boot:run -Dspring-boot.run.profiles=dev
```

2. ブラウザで `http://localhost:8080/api/auth/login` にアクセス
3. Fitbit の同意画面にリダイレクトされることを確認
4. ログイン後、`/dashboard` にリダイレクトされることを確認
5. DBを確認:
```bash
psql -h localhost -U postgres -d fitbit_agent -c 'SELECT id, fitbit_user_id FROM users;'
psql -h localhost -U postgres -d fitbit_agent -c 'SELECT id, user_id, expires_at FROM oauth_tokens;'
```

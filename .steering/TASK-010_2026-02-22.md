# TASK-010: Fitbit OAuth2.0 ログイン（バックエンド）

## 概要
Spring Security + OAuth2 Client で Fitbit OAuth2.0 認証を実装する。
ユーザーが Fitbit アカウントでログインし、アクセストークンを暗号化してDBに保存する。

## 受入条件
- [ ] `GET /api/auth/login` でFitbit認可URLにリダイレクトされる
- [ ] `GET /api/auth/callback` でトークン取得・暗号化保存・セッション生成が行われる
- [ ] トークン自動リフレッシュが動作する

## 参照ドキュメント
- OAuth2.0フロー: docs/basic-functional-design.md セクション6.2
- セキュリティ設計: docs/architecture.md セクション6
- パッケージ構成: docs/architecture.md セクション3.2

## 事前確認（着手前に必要）
- Fitbit Developer Console でアプリを登録し、以下を取得する必要がある
  - `FITBIT_CLIENT_ID`
  - `FITBIT_CLIENT_SECRET`
  - Callback URL: `http://localhost:8080/api/auth/callback`

## 作業手順

- [x] Step 1: Enum 作成（GoalType / AdviceType / ChatRole）
- [ ] Step 2: User エンティティ作成
- [ ] Step 3: OAuthToken エンティティ作成
- [ ] Step 4: UserRepository / OAuthTokenRepository 作成
- [ ] Step 5: TokenEncryptionService 作成（AES-256-GCM）
- [ ] Step 6: FitbitConfig 作成
- [ ] Step 7: application-dev.yml に Fitbit OAuth2 設定追加
- [ ] Step 8: SecurityConfig 作成
- [ ] Step 9: FitbitOAuthClient 作成（トークン交換・リフレッシュ）
- [ ] Step 10: AuthService 作成
- [ ] Step 11: AuthController 作成
- [ ] Step 12: WebConfig 作成（CORS設定）
- [ ] Step 13: GlobalExceptionHandler 作成
- [ ] Step 14: 動作確認

---

## Step 1: Enum 作成

後続タスクでも使う列挙型を先に作成する。

### GoalType.java
**ファイルパス**: `backend/src/main/java/com/fitbitagent/domain/enums/GoalType.java`

目標の種別を表す。goals テーブルの `goal_type` カラムの値に対応する。

```java
package com.fitbitagent.domain.enums;

public enum GoalType {
    WEIGHT,
    STEPS,
    CALORIES_BURNED,
    CALORIES_INTAKE
}
```

### AdviceType.java
**ファイルパス**: `backend/src/main/java/com/fitbitagent/domain/enums/AdviceType.java`

```java
package com.fitbitagent.domain.enums;

public enum AdviceType {
    DAILY,
    WEEKLY
}
```

### ChatRole.java
**ファイルパス**: `backend/src/main/java/com/fitbitagent/domain/enums/ChatRole.java`

```java
package com.fitbitagent.domain.enums;

public enum ChatRole {
    USER,
    ASSISTANT
}
```

---

## Step 2: User エンティティ作成

**ファイルパス**: `backend/src/main/java/com/fitbitagent/domain/entity/User.java`

JPA エンティティ = DBのテーブル1行を表すJavaクラス。`@Entity` を付けることでSpringが自動管理する。

```java
package com.fitbitagent.domain.entity;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Builder;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.UUID;

@Entity
@Table(name = "users")
@Getter
@NoArgsConstructor
@Builder
public class User {

    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    private UUID id;

    @Column(name = "fitbit_user_id", nullable = false, unique = true, length = 64)
    private String fitbitUserId;

    @Column(name = "display_name", length = 255)
    private String displayName;

    @Column(name = "gender", length = 16)
    private String gender;

    @Column(name = "height_cm", precision = 5, scale = 1)
    private BigDecimal heightCm;

    @Column(name = "date_of_birth")
    private LocalDate dateOfBirth;

    @Column(name = "activity_level", length = 32)
    private String activityLevel;

    @CreationTimestamp
    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @UpdateTimestamp
    @Column(name = "updated_at", nullable = false)
    private LocalDateTime updatedAt;

    // 既存ユーザーのプロフィール更新用メソッド
    public void updateProfile(String displayName, String gender, BigDecimal heightCm,
                              LocalDate dateOfBirth, String activityLevel) {
        this.displayName = displayName;
        this.gender = gender;
        this.heightCm = heightCm;
        this.dateOfBirth = dateOfBirth;
        this.activityLevel = activityLevel;
    }
}
```

**主要アノテーションの説明**:
- `@Entity` — このクラスがDBテーブルに対応することを示す
- `@Table(name = "users")` — 対応するテーブル名を指定
- `@Id` — 主キーを示す
- `@GeneratedValue(strategy = GenerationType.UUID)` — UUIDを自動生成
- `@Column` — カラムの詳細設定（nullable, unique, length等）
- `@CreationTimestamp` / `@UpdateTimestamp` — Hibernateが自動でタイムスタンプをセット
- `@Getter` / `@NoArgsConstructor` / `@Builder` — Lombokで定型コードを自動生成

---

## Step 3: OAuthToken エンティティ作成

**ファイルパス**: `backend/src/main/java/com/fitbitagent/domain/entity/OAuthToken.java`

```java
package com.fitbitagent.domain.entity;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Builder;

import java.time.LocalDateTime;
import java.util.UUID;

@Entity
@Table(name = "oauth_tokens")
@Getter
@NoArgsConstructor
@Builder
public class OAuthToken {

    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    private UUID id;

    @OneToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id", nullable = false, unique = true)
    private User user;

    @Column(name = "access_token", nullable = false, length = 1024)
    private String accessToken;

    @Column(name = "refresh_token", nullable = false, length = 1024)
    private String refreshToken;

    @Column(name = "expires_at", nullable = false)
    private LocalDateTime expiresAt;

    @Column(name = "scope", nullable = false, length = 255)
    private String scope;

    // トークン更新用メソッド
    public void updateTokens(String accessToken, String refreshToken, LocalDateTime expiresAt) {
        this.accessToken = accessToken;
        this.refreshToken = refreshToken;
        this.expiresAt = expiresAt;
    }

    public boolean isExpired() {
        return LocalDateTime.now().isAfter(expiresAt.minusMinutes(5));
    }
}
```

**ポイント**:
- `@OneToOne` — User と OAuthToken は 1:1 の関係
- `FetchType.LAZY` — 必要になるまでJOINしない（パフォーマンス最適化）
- `isExpired()` — 有効期限の5分前から「期限切れ」とみなす（早めにリフレッシュするため）

---

## Step 4: Repository 作成

Spring Data JPA の Repository は「インターフェースを書くだけでDB操作メソッドが自動生成される」仕組み。

### UserRepository.java
**ファイルパス**: `backend/src/main/java/com/fitbitagent/repository/UserRepository.java`

```java
package com.fitbitagent.repository;

import com.fitbitagent.domain.entity.User;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.Optional;
import java.util.UUID;

public interface UserRepository extends JpaRepository<User, UUID> {
    Optional<User> findByFitbitUserId(String fitbitUserId);
}
```

### OAuthTokenRepository.java
**ファイルパス**: `backend/src/main/java/com/fitbitagent/repository/OAuthTokenRepository.java`

```java
package com.fitbitagent.repository;

import com.fitbitagent.domain.entity.OAuthToken;
import com.fitbitagent.domain.entity.User;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.Optional;
import java.util.UUID;

public interface OAuthTokenRepository extends JpaRepository<OAuthToken, UUID> {
    Optional<OAuthToken> findByUser(User user);
}
```

**ポイント**:
- `JpaRepository<エンティティ型, 主キーの型>` を継承するだけで、save/findById/delete などが自動生成される
- メソッド名のルール: `findBy{カラム名}` と書くだけでSELECT文が自動生成される（Spring Data JPA のクエリメソッド）

---

## Step 5: TokenEncryptionService 作成

**ファイルパス**: `backend/src/main/java/com/fitbitagent/service/TokenEncryptionService.java`

Fitbit のアクセストークン・リフレッシュトークンを AES-256-GCM で暗号化してDBに保存する。
（暗号化しないと、DB流出時にトークンが悪用されるリスクがある）

```java
package com.fitbitagent.service;

import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;

import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.spec.GCMParameterSpec;
import javax.crypto.spec.SecretKeySpec;
import java.security.SecureRandom;
import java.util.Base64;

@Service
@Slf4j
public class TokenEncryptionService {

    private static final String ALGORITHM = "AES/GCM/NoPadding";
    private static final int GCM_IV_LENGTH = 12;
    private static final int GCM_TAG_LENGTH = 128;

    private final SecretKey secretKey;

    public TokenEncryptionService(@Value("${app.token-encryption-key}") String base64Key) {
        byte[] keyBytes = Base64.getDecoder().decode(base64Key);
        this.secretKey = new SecretKeySpec(keyBytes, "AES");
    }

    public String encrypt(String plainText) {
        try {
            byte[] iv = new byte[GCM_IV_LENGTH];
            new SecureRandom().nextBytes(iv);

            Cipher cipher = Cipher.getInstance(ALGORITHM);
            cipher.init(Cipher.ENCRYPT_MODE, secretKey, new GCMParameterSpec(GCM_TAG_LENGTH, iv));

            byte[] encrypted = cipher.doFinal(plainText.getBytes());
            byte[] combined = new byte[iv.length + encrypted.length];
            System.arraycopy(iv, 0, combined, 0, iv.length);
            System.arraycopy(encrypted, 0, combined, iv.length, encrypted.length);

            return Base64.getEncoder().encodeToString(combined);
        } catch (Exception e) {
            throw new RuntimeException("Token encryption failed", e);
        }
    }

    public String decrypt(String encryptedText) {
        try {
            byte[] combined = Base64.getDecoder().decode(encryptedText);
            byte[] iv = new byte[GCM_IV_LENGTH];
            System.arraycopy(combined, 0, iv, 0, iv.length);
            byte[] encrypted = new byte[combined.length - iv.length];
            System.arraycopy(combined, iv.length, encrypted, 0, encrypted.length);

            Cipher cipher = Cipher.getInstance(ALGORITHM);
            cipher.init(Cipher.DECRYPT_MODE, secretKey, new GCMParameterSpec(GCM_TAG_LENGTH, iv));

            return new String(cipher.doFinal(encrypted));
        } catch (Exception e) {
            throw new RuntimeException("Token decryption failed", e);
        }
    }
}
```

**設定が必要**: `application-dev.yml` に `app.token-encryption-key` を追加する（Step 7で行う）。
暗号化キーは Base64 エンコードされた 32バイト（256bit）のランダム文字列。

開発用キーの生成コマンド:
```bash
openssl rand -base64 32
```

---

## Step 6: FitbitConfig 作成

**ファイルパス**: `backend/src/main/java/com/fitbitagent/config/FitbitConfig.java`

`application.yml` の設定値を Java クラスとして読み込む。

```java
package com.fitbitagent.config;

import lombok.Getter;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Configuration;

@Configuration
@Getter
public class FitbitConfig {

    @Value("${fitbit.client-id}")
    private String clientId;

    @Value("${fitbit.client-secret}")
    private String clientSecret;

    @Value("${fitbit.redirect-uri}")
    private String redirectUri;

    @Value("${fitbit.authorization-uri:https://www.fitbit.com/oauth2/authorize}")
    private String authorizationUri;

    @Value("${fitbit.token-uri:https://api.fitbit.com/oauth2/token}")
    private String tokenUri;

    @Value("${fitbit.api-base-url:https://api.fitbit.com}")
    private String apiBaseUrl;

    @Value("${fitbit.scope:activity heartrate location nutrition profile settings sleep social weight}")
    private String scope;
}
```

---

## Step 7: application-dev.yml に設定追加

**ファイルパス**: `backend/src/main/resources/application-dev.yml`

以下を追記する:

```yaml
fitbit:
  client-id: ${FITBIT_CLIENT_ID}
  client-secret: ${FITBIT_CLIENT_SECRET}
  redirect-uri: http://localhost:8080/api/auth/callback

app:
  token-encryption-key: ${TOKEN_ENCRYPTION_KEY}
```

**環境変数の設定方法**（ターミナルで実行）:
```bash
# 暗号化キーを生成して設定
export TOKEN_ENCRYPTION_KEY=$(openssl rand -base64 32)
export FITBIT_CLIENT_ID=your_client_id
export FITBIT_CLIENT_SECRET=your_client_secret
```

または `docker/.env` に追記して管理してもよい。

---

## Step 8: SecurityConfig 作成

**ファイルパス**: `backend/src/main/java/com/fitbitagent/config/SecurityConfig.java`

Spring Security の設定。どのエンドポイントを保護するか、CSRFの扱いなどを定義する。

```java
package com.fitbitagent.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.csrf.CookieCsrfTokenRepository;

@Configuration
@EnableWebSecurity
public class SecurityConfig {

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/api/auth/login", "/api/auth/callback").permitAll()
                .anyRequest().authenticated()
            )
            .csrf(csrf -> csrf
                .csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse())
                .ignoringRequestMatchers("/api/auth/callback")
            )
            .sessionManagement(session -> session
                .maximumSessions(1)
            );

        return http.build();
    }
}
```

**ポイント**:
- `permitAll()` — `/api/auth/login` と `/api/auth/callback` は未認証でもアクセス可能にする
- `anyRequest().authenticated()` — それ以外は認証必須
- `CookieCsrfTokenRepository` — CSRFトークンをCookieで管理（フロントエンドから送信可能にするため `HttpOnlyFalse`）
- `/api/auth/callback` は Fitbit からのリダイレクトなので CSRF チェック対象外にする

---

## Step 9: FitbitOAuthClient 作成

**ファイルパス**: `backend/src/main/java/com/fitbitagent/client/fitbit/FitbitOAuthClient.java`

Fitbit の OAuth2.0 エンドポイントと通信する。認可コード → トークン交換とトークンリフレッシュを担当。

```java
package com.fitbitagent.client.fitbit;

import com.fitbitagent.config.FitbitConfig;
import com.fitbitagent.exception.FitbitApiException;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;
import org.springframework.util.LinkedMultiValueMap;
import org.springframework.util.MultiValueMap;
import org.springframework.web.reactive.function.BodyInserters;
import org.springframework.web.reactive.function.client.WebClient;

import java.util.Map;

@Component
@RequiredArgsConstructor
@Slf4j
public class FitbitOAuthClient {

    private final FitbitConfig fitbitConfig;
    private final WebClient webClient;

    // 認可コードをアクセストークンに交換する
    public Map<String, Object> exchangeCodeForToken(String code) {
        MultiValueMap<String, String> body = new LinkedMultiValueMap<>();
        body.add("grant_type", "authorization_code");
        body.add("code", code);
        body.add("redirect_uri", fitbitConfig.getRedirectUri());

        return callTokenEndpoint(body);
    }

    // リフレッシュトークンで新しいアクセストークンを取得する
    public Map<String, Object> refreshToken(String refreshToken) {
        MultiValueMap<String, String> body = new LinkedMultiValueMap<>();
        body.add("grant_type", "refresh_token");
        body.add("refresh_token", refreshToken);

        return callTokenEndpoint(body);
    }

    @SuppressWarnings("unchecked")
    private Map<String, Object> callTokenEndpoint(MultiValueMap<String, String> body) {
        try {
            return webClient.post()
                    .uri(fitbitConfig.getTokenUri())
                    .headers(headers -> headers.setBasicAuth(
                            fitbitConfig.getClientId(),
                            fitbitConfig.getClientSecret()))
                    .body(BodyInserters.fromFormData(body))
                    .retrieve()
                    .bodyToMono(Map.class)
                    .block();
        } catch (Exception e) {
            log.error("Failed to call Fitbit token endpoint", e);
            throw new FitbitApiException("Failed to obtain token from Fitbit", e);
        }
    }
}
```

**WebBean の登録も必要**。`SecurityConfig.java` か新しい Config クラスに以下を追加:

```java
@Bean
public WebClient webClient() {
    return WebClient.builder()
            .defaultHeader("Content-Type", "application/x-www-form-urlencoded")
            .build();
}
```

---

## Step 10: 例外クラス作成

`FitbitOAuthClient` で使う例外クラスを先に作る。

### FitbitApiException.java
**ファイルパス**: `backend/src/main/java/com/fitbitagent/exception/FitbitApiException.java`

```java
package com.fitbitagent.exception;

public class FitbitApiException extends RuntimeException {
    public FitbitApiException(String message) {
        super(message);
    }
    public FitbitApiException(String message, Throwable cause) {
        super(message, cause);
    }
}
```

---

## Step 11: AuthService 作成

**ファイルパス**: `backend/src/main/java/com/fitbitagent/service/AuthService.java`

OAuth2.0 コールバック処理のビジネスロジック。トークン交換 → ユーザー作成/更新 → セッション生成を行う。

```java
package com.fitbitagent.service;

import com.fitbitagent.client.fitbit.FitbitOAuthClient;
import com.fitbitagent.config.FitbitConfig;
import com.fitbitagent.domain.entity.OAuthToken;
import com.fitbitagent.domain.entity.User;
import com.fitbitagent.repository.OAuthTokenRepository;
import com.fitbitagent.repository.UserRepository;
import jakarta.servlet.http.HttpSession;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.util.UriComponentsBuilder;

import java.time.LocalDateTime;
import java.util.Map;
import java.util.UUID;

@Service
@RequiredArgsConstructor
@Slf4j
public class AuthService {

    private final FitbitConfig fitbitConfig;
    private final FitbitOAuthClient fitbitOAuthClient;
    private final UserRepository userRepository;
    private final OAuthTokenRepository oAuthTokenRepository;
    private final TokenEncryptionService tokenEncryptionService;

    // Fitbit 認可URLを生成する
    public String buildAuthorizationUrl(String state) {
        return UriComponentsBuilder.fromHttpUrl(fitbitConfig.getAuthorizationUri())
                .queryParam("response_type", "code")
                .queryParam("client_id", fitbitConfig.getClientId())
                .queryParam("redirect_uri", fitbitConfig.getRedirectUri())
                .queryParam("scope", fitbitConfig.getScope())
                .queryParam("state", state)
                .toUriString();
    }

    // コールバック処理: トークン取得 → ユーザー保存 → セッション生成
    @Transactional
    public User handleCallback(String code, HttpSession session) {
        // 1. 認可コード → トークン交換
        Map<String, Object> tokenResponse = fitbitOAuthClient.exchangeCodeForToken(code);

        String accessToken = (String) tokenResponse.get("access_token");
        String refreshToken = (String) tokenResponse.get("refresh_token");
        Integer expiresIn = (Integer) tokenResponse.get("expires_in");
        String userId = (String) tokenResponse.get("user_id");
        String scope = (String) tokenResponse.get("scope");

        LocalDateTime expiresAt = LocalDateTime.now().plusSeconds(expiresIn);

        // 2. ユーザーを取得または新規作成
        User user = userRepository.findByFitbitUserId(userId)
                .orElseGet(() -> userRepository.save(
                        User.builder()
                                .fitbitUserId(userId)
                                .build()
                ));

        // 3. トークンを暗号化してDBに保存（UPSERT）
        String encryptedAccess = tokenEncryptionService.encrypt(accessToken);
        String encryptedRefresh = tokenEncryptionService.encrypt(refreshToken);

        oAuthTokenRepository.findByUser(user)
                .ifPresentOrElse(
                        token -> token.updateTokens(encryptedAccess, encryptedRefresh, expiresAt),
                        () -> oAuthTokenRepository.save(OAuthToken.builder()
                                .user(user)
                                .accessToken(encryptedAccess)
                                .refreshToken(encryptedRefresh)
                                .expiresAt(expiresAt)
                                .scope(scope)
                                .build())
                );

        // 4. セッションにユーザーIDを保存
        session.setAttribute("userId", user.getId());
        log.info("User logged in: {}", user.getId());

        return user;
    }

    // トークンリフレッシュ
    @Transactional
    public void refreshToken(User user) {
        OAuthToken token = oAuthTokenRepository.findByUser(user)
                .orElseThrow(() -> new RuntimeException("Token not found for user: " + user.getId()));

        String decryptedRefreshToken = tokenEncryptionService.decrypt(token.getRefreshToken());
        Map<String, Object> tokenResponse = fitbitOAuthClient.refreshToken(decryptedRefreshToken);

        String newAccessToken = (String) tokenResponse.get("access_token");
        String newRefreshToken = (String) tokenResponse.get("refresh_token");
        Integer expiresIn = (Integer) tokenResponse.get("expires_in");

        token.updateTokens(
                tokenEncryptionService.encrypt(newAccessToken),
                tokenEncryptionService.encrypt(newRefreshToken),
                LocalDateTime.now().plusSeconds(expiresIn)
        );
    }
}
```

---

## Step 12: AuthController 作成

**ファイルパス**: `backend/src/main/java/com/fitbitagent/controller/AuthController.java`

```java
package com.fitbitagent.controller;

import com.fitbitagent.service.AuthService;
import jakarta.servlet.http.HttpSession;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.servlet.view.RedirectView;

import java.util.UUID;

@RestController
@RequestMapping("/api/auth")
@RequiredArgsConstructor
@Slf4j
public class AuthController {

    private final AuthService authService;

    // ログイン: Fitbit 認可URLへリダイレクト
    @GetMapping("/login")
    public RedirectView login(HttpSession session) {
        String state = UUID.randomUUID().toString();
        session.setAttribute("oauth_state", state);
        String authorizationUrl = authService.buildAuthorizationUrl(state);
        return new RedirectView(authorizationUrl);
    }

    // コールバック: Fitbit から認可コードを受け取る
    @GetMapping("/callback")
    public RedirectView callback(@RequestParam String code,
                                  @RequestParam String state,
                                  HttpSession session) {
        // state 検証（CSRF対策）
        String savedState = (String) session.getAttribute("oauth_state");
        if (!state.equals(savedState)) {
            log.warn("OAuth state mismatch. Expected: {}, Got: {}", savedState, state);
            return new RedirectView("/login?error=invalid_state");
        }

        authService.handleCallback(code, session);
        return new RedirectView("/dashboard");
    }

    // ログアウト
    @PostMapping("/logout")
    @ResponseStatus(HttpStatus.NO_CONTENT)
    public void logout(HttpSession session) {
        session.invalidate();
    }
}
```

---

## Step 13: WebConfig 作成（CORS設定）

**ファイルパス**: `backend/src/main/java/com/fitbitagent/config/WebConfig.java`

フロントエンド（localhost:5173）からのリクエストを許可する。

```java
package com.fitbitagent.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.CorsRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class WebConfig implements WebMvcConfigurer {

    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/api/**")
                .allowedOrigins("http://localhost:5173")
                .allowedMethods("GET", "POST", "PUT", "DELETE")
                .allowedHeaders("Content-Type", "X-CSRF-TOKEN")
                .allowCredentials(true);
    }
}
```

---

## Step 14: 動作確認

1. 環境変数を設定して Spring Boot を起動:
```bash
export TOKEN_ENCRYPTION_KEY=$(openssl rand -base64 32)
export FITBIT_CLIENT_ID=your_client_id
export FITBIT_CLIENT_SECRET=your_client_secret
cd backend && mvn spring-boot:run -Dspring-boot.run.profiles=dev
```

2. ブラウザで `http://localhost:8080/api/auth/login` にアクセス
3. Fitbit の同意画面にリダイレクトされることを確認
4. ログイン後、`/dashboard` にリダイレクトされることを確認
5. DBを確認:
```bash
psql -h localhost -U postgres -d fitbit_agent -c 'SELECT id, fitbit_user_id FROM users;'
psql -h localhost -U postgres -d fitbit_agent -c 'SELECT id, user_id, expires_at FROM oauth_tokens;'
```

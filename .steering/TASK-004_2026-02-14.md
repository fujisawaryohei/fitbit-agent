# TASK-004: Flyway DBマイグレーション初期設定

## 概要
基本設計書（docs/basic-functional-design.md セクション4）のデータモデルに基づき、
Flywayマイグレーションファイルを作成し、全テーブル・インデックスをDBに作成する。

## 受入条件
- [ ] 全テーブル（users, oauth_tokens, body_records, activity_records, sleep_records, nutrition_records, heart_rate_records, goals, ai_advices, chat_messages）が作成される
- [ ] インデックスが設計通りに作成される
- [ ] アプリ起動時にFlywayが自動実行されてテーブルが作成される

## 参照ドキュメント
- データモデル: docs/basic-functional-design.md セクション4
- 命名規則（DB）: docs/development-guidelines.md セクション3.4
- アーキテクチャ: docs/architecture.md セクション3.1

## 作業手順

- [x] Step 1: マイグレーションディレクトリ作成
- [x] Step 2: V1__create_users.sql 作成
- [x] Step 3: V2__create_oauth_tokens.sql 作成
- [x] Step 4: V3__create_body_records.sql 作成
- [x] Step 5: V4__create_activity_records.sql 作成
- [x] Step 6: V5__create_sleep_records.sql 作成
- [x] Step 7: V6__create_nutrition_records.sql 作成
- [x] Step 8: V7__create_heart_rate_records.sql 作成
- [x] Step 9: V8__create_goals.sql 作成
- [x] Step 10: V9__create_ai_advices.sql 作成
- [x] Step 11: V10__create_chat_messages.sql 作成
- [x] Step 12: application-dev.yml にFlyway設定追加
- [x] Step 13: Docker Compose で動作確認

---

## Step 1: マイグレーションディレクトリ作成

**何をするか**: Flywayがマイグレーションファイルを読み込むためのディレクトリを作成する。

**作成するディレクトリ**:
```
backend/src/main/resources/db/migration/
```

**なぜこのパスか**: Flywayのデフォルト設定で `classpath:db/migration` を自動検索するため、
この場所にSQLファイルを配置するだけで自動認識される。

**確認方法**: ディレクトリが存在すること。

---

## Step 2: V1__create_users.sql

**何を作るか**: `users` テーブルを作成するマイグレーションファイル。

**ファイルパス**: `backend/src/main/resources/db/migration/V1__create_users.sql`

**ファイル名のルール**（開発ガイドライン 3.4）:
- `V{番号}__{説明}.sql`（Vの後に番号、アンダースコア2つ、説明）

**SQLの書き方**:
```sql
CREATE TABLE users (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    fitbit_user_id VARCHAR(64) NOT NULL,
    display_name VARCHAR(255),
    gender VARCHAR(16),
    height_cm DECIMAL(5,1),
    date_of_birth DATE,
    activity_level VARCHAR(32),
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT uk_users_fitbit_user_id UNIQUE (fitbit_user_id)
);
```

**ポイント**:
- `UUID` 型の主キーは `gen_random_uuid()` でデフォルト値を自動生成する（PostgreSQL組み込み関数）
- `created_at`, `updated_at` は `DEFAULT CURRENT_TIMESTAMP` で自動設定
- `fitbit_user_id` にUNIQUE制約を付ける（設計書の「インデックス: fitbit_user_id (UNIQUE)」に対応）
- 制約名は `uk_{テーブル}_{カラム}` 形式にする

**確認方法**: ファイルの中身がSQL文として正しいか（構文エラーがないか）。

---

## Step 3: V2__create_oauth_tokens.sql

**ファイルパス**: `backend/src/main/resources/db/migration/V2__create_oauth_tokens.sql`

**SQLの書き方**:
```sql
CREATE TABLE oauth_tokens (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL,
    access_token VARCHAR(1024) NOT NULL,
    refresh_token VARCHAR(1024) NOT NULL,
    expires_at TIMESTAMP NOT NULL,
    scope VARCHAR(255) NOT NULL,
    CONSTRAINT fk_oauth_tokens_user FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
    CONSTRAINT uk_oauth_tokens_user_id UNIQUE (user_id)
);
```

**ポイント**:
- `FOREIGN KEY (user_id) REFERENCES users(id)` で users テーブルとの関連を定義
- `ON DELETE CASCADE`: ユーザーが削除されたらトークンも自動削除
- `user_id` にUNIQUE制約（1ユーザー1トークンの1:1関係）

---

## Step 4: V3__create_body_records.sql

**ファイルパス**: `backend/src/main/resources/db/migration/V3__create_body_records.sql`

**SQLの書き方**:
```sql
CREATE TABLE body_records (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL,
    record_date DATE NOT NULL,
    weight_kg DECIMAL(5,2),
    body_fat_pct DECIMAL(4,1),
    bmi DECIMAL(4,1),
    CONSTRAINT fk_body_records_user FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
    CONSTRAINT uk_body_records_user_date UNIQUE (user_id, record_date)
);

CREATE INDEX idx_body_records_user_date ON body_records(user_id, record_date);
```

**ポイント**:
- `(user_id, record_date)` の複合ユニーク制約: 1ユーザーにつき1日1レコード
- `CREATE INDEX` でインデックスも明示的に作成（UNIQUE制約でインデックスは自動作成されるが、明示しておくと設計意図が明確になる）

**注意**: UNIQUE制約を付けると自動でインデックスが作成されるため、別途 `CREATE INDEX` は不要という考え方もある。今回はUNIQUE制約で十分なので、**`CREATE INDEX` は省略してもOK**。お好みでどちらでも構わない。

---

## Step 5〜7: activity_records / sleep_records / nutrition_records

Step 4 と同じパターン。設計書のカラム定義に合わせて書く。

**Step 5** - `V4__create_activity_records.sql`:
```sql
CREATE TABLE activity_records (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL,
    record_date DATE NOT NULL,
    steps INTEGER,
    calories_burned INTEGER,
    active_minutes INTEGER,
    CONSTRAINT fk_activity_records_user FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
    CONSTRAINT uk_activity_records_user_date UNIQUE (user_id, record_date)
);
```

**Step 6** - `V5__create_sleep_records.sql`:
```sql
CREATE TABLE sleep_records (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL,
    record_date DATE NOT NULL,
    total_minutes INTEGER,
    deep_minutes INTEGER,
    light_minutes INTEGER,
    rem_minutes INTEGER,
    wake_minutes INTEGER,
    CONSTRAINT fk_sleep_records_user FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
    CONSTRAINT uk_sleep_records_user_date UNIQUE (user_id, record_date)
);
```

**Step 7** - `V6__create_nutrition_records.sql`:
```sql
CREATE TABLE nutrition_records (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL,
    record_date DATE NOT NULL,
    calories_intake INTEGER,
    water_ml INTEGER,
    CONSTRAINT fk_nutrition_records_user FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
    CONSTRAINT uk_nutrition_records_user_date UNIQUE (user_id, record_date)
);
```

---

## Step 8: V7__create_heart_rate_records.sql

```sql
CREATE TABLE heart_rate_records (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL,
    record_date DATE NOT NULL,
    resting_hr INTEGER,
    CONSTRAINT fk_heart_rate_records_user FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
    CONSTRAINT uk_heart_rate_records_user_date UNIQUE (user_id, record_date)
);
```

---

## Step 9: V8__create_goals.sql

**ポイント**: `is_active` のデフォルト値は `true`。インデックスは `(user_id, goal_type, is_active)` の複合。

```sql
CREATE TABLE goals (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL,
    goal_type VARCHAR(32) NOT NULL,
    target_value DECIMAL(10,2) NOT NULL,
    target_date DATE,
    is_active BOOLEAN NOT NULL DEFAULT true,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT fk_goals_user FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);

CREATE INDEX idx_goals_user_type_active ON goals(user_id, goal_type, is_active);
```

**注意**: goals テーブルのインデックスはUNIQUEではない（同じ種別の目標履歴を残すため）。
そのため `UNIQUE` 制約ではなく通常の `CREATE INDEX` を使う。

---

## Step 10: V9__create_ai_advices.sql

```sql
CREATE TABLE ai_advices (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL,
    advice_type VARCHAR(16) NOT NULL,
    advice_date DATE NOT NULL,
    content TEXT NOT NULL,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT fk_ai_advices_user FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);

CREATE INDEX idx_ai_advices_user_type_date ON ai_advices(user_id, advice_type, advice_date);
```

---

## Step 11: V10__create_chat_messages.sql

```sql
CREATE TABLE chat_messages (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL,
    session_id UUID NOT NULL,
    role VARCHAR(16) NOT NULL,
    content TEXT NOT NULL,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT fk_chat_messages_user FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);

CREATE INDEX idx_chat_messages_user_session_created ON chat_messages(user_id, session_id, created_at);
```

---

## Step 12: application-dev.yml にFlyway設定追加

**ファイルパス**: `backend/src/main/resources/application-dev.yml`

以下を追加する:
```yaml
spring:
  flyway:
    enabled: true
    locations: classpath:db/migration
```

**なぜ**: `application.yml`（共通設定）の `jpa.hibernate.ddl-auto: validate` により、
HibernateはDDL実行をせず、テーブルの存在検証のみ行う。
テーブル作成はFlywayのマイグレーションが担当する。
Flywayはデフォルトで有効だが、明示しておくと設定が分かりやすい。

---

## Step 13: Docker Compose で動作確認

**手順**:
1. `docker compose -f docker/docker-compose.yml up -d` でPostgreSQLを起動
2. `cd backend && mvn spring-boot:run -Dspring-boot.run.profiles=dev` でSpring Bootを起動
3. コンソールログに `Successfully applied X migrations` のようなメッセージが表示されることを確認
4. PostgreSQLに接続して全テーブルが作成されていることを確認:
   ```bash
   docker exec -it fitbit-postgres psql -U postgres -d fitbit_agent -c '\dt'
   ```

**期待結果**: 10テーブル + Flywayの管理テーブル（`flyway_schema_history`）が表示される。

# TASK-010 作業指示書: Fitbit OAuth2.0 ログイン（バックエンド）

**作成日**: 2026-02-19
**担当**: ユーザー
**参照チケット**: .steering/tasklist.md > TASK-010

---

## 受入条件

- [ ] `GET /api/auth/login` でFitbit認可URLにリダイレクトされる
- [ ] `GET /api/auth/callback` でトークン取得・暗号化保存・セッション生成が行われる
- [ ] トークン自動リフレッシュが動作する（FitbitOAuthClient にリフレッシュメソッドが実装されている）

---

## 作業手順 進捗一覧

- [x] Step 1: 設定ファイル（application-dev.yml）に Fitbit OAuth2.0 設定を追記する
- [ ] Step 2: User.java / OAuthToken.java エンティティを作成する
- [ ] Step 3: UserRepository.java / OAuthTokenRepository.java を作成する
- [ ] Step 4: TokenEncryptionService.java を作成する（AES-256-GCM暗号化）
- [ ] Step 5: FitbitConfig.java / FitbitOAuthClient.java を作成する
- [ ] Step 6: AuthService.java / OAuth2AuthenticationSuccessHandler.java を作成する
- [ ] Step 7: AuthController.java / SecurityConfig.java / WebConfig.java を作成する（認証フロー完成）

---

## 作業手順 詳細

---

### Step 1: 設定ファイルに Fitbit OAuth2.0 設定を追記する

#### 何を作るか
`backend/src/main/resources/application-dev.yml` を編集する。

Spring Securityは `spring.security.oauth2.client` の設定を読んで、自動的に OAuth2 ログインを構成する。
Fitbit は Spring Security に組み込みで対応していない（GitHub / Google / Kakaoなどと違う）ため、
provider（認可サーバーのURL）を手動で設定する必要がある。

#### どう作るか

以下の設定ブロックを `application-dev.yml` に追記する。

```yaml
spring:
  security:
    oauth2:
      client:
        registration:
          fitbit:
            client-id: ${FITBIT_CLIENT_ID}
            client-secret: ${FITBIT_CLIENT_SECRET}
            authorization-grant-type: authorization_code
            redirect-uri: "{baseUrl}/api/auth/callback"
            scope: activity,body,sleep,nutrition,heartrate,profile
        provider:
          fitbit:
            authorization-uri: https://www.fitbit.com/oauth2/authorize
            token-uri: https://api.fitbit.com/oauth2/token
            user-info-uri: https://api.fitbit.com/1/user/-/profile.json
            user-name-attribute: encodedId

fitbit:
  client-id: ${FITBIT_CLIENT_ID}
  client-secret: ${FITBIT_CLIENT_SECRET}
  token-uri: https://api.fitbit.com/oauth2/token

token:
  encryption-key: ${TOKEN_ENCRYPTION_KEY:dev-encryption-key-32bytes-pad!}
```

**設定値の意味:**
| 設定キー | 意味 |
|---------|------|
| `registration.fitbit.scope` | Fitbit APIで取得したいデータの種類（体重・活動・睡眠など） |
| `registration.fitbit.redirect-uri` | 認証後にFitbitが戻ってくるURL。`{baseUrl}` はSpringが自動補完する |
| `provider.fitbit.authorization-uri` | ユーザーがFitbitにログインするURL（認可画面） |
| `provider.fitbit.token-uri` | code → token に交換するURL |
| `provider.fitbit.user-name-attribute` | Fitbit profile APIのどのフィールドをユーザー識別子に使うか |
| `token.encryption-key` | DBに保存するトークンを暗号化するキー（開発用はデフォルト値を使用） |

**なぜそうするか:**
- docs/architecture.md §6.1 OAuth2.0認証フロー詳細 に基づく
- `redirect-uri` の `/api/auth/callback` は設計書の `GET /api/auth/callback` エンドポイントに対応

**確認方法:**
```bash
cd backend && mvn spring-boot:run
```
起動してエラーが出ないことを確認する（この段階ではまだ SecurityConfig がないためエラーが出る可能性があるが、設定ファイルのYAML構文エラーがないことを確認する）。

---

### Step 2: User.java / OAuthToken.java エンティティを作成する

#### 何を作るか

| ファイル | パッケージ | 役割 |
|---------|----------|------|
| `User.java` | `com.fitbitagent.domain.entity` | usersテーブルに対応するJPAエンティティ |
| `OAuthToken.java` | `com.fitbitagent.domain.entity` | oauth_tokensテーブルに対応するJPAエンティティ |

**JPAエンティティとは?**
データベースのテーブルと Java のクラスを対応させる仕組み。
`@Entity` アノテーションを付けると Spring Boot が自動的に対応するテーブルにデータを読み書きしてくれる。

#### どう作るか（User.java）

```java
package com.fitbitagent.domain.entity;

import jakarta.persistence.*;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import java.math.BigDecimal;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.UUID;

@Entity
@Table(name = "users")
@Getter
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class User {

    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    private UUID id;

    @Column(name = "fitbit_user_id", nullable = false, unique = true, length = 64)
    private String fitbitUserId;

    @Column(name = "display_name")
    private String displayName;

    @Column(name = "gender", length = 16)
    private String gender;

    @Column(name = "height_cm", precision = 5, scale = 1)
    private BigDecimal heightCm;

    @Column(name = "date_of_birth")
    private LocalDate dateOfBirth;

    @Column(name = "activity_level", length = 32)
    private String activityLevel;

    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @Column(name = "updated_at", nullable = false)
    private LocalDateTime updatedAt;

    @PrePersist
    protected void onCreate() {
        createdAt = LocalDateTime.now();
        updatedAt = LocalDateTime.now();
    }

    @PreUpdate
    protected void onUpdate() {
        updatedAt = LocalDateTime.now();
    }

    // displayNameを更新するためのメソッド（Builderで不変にしつつ、必要な更新のみ許可）
    public void updateProfile(String displayName, String gender, BigDecimal heightCm,
                               LocalDate dateOfBirth, String activityLevel) {
        this.displayName = displayName;
        this.gender = gender;
        this.heightCm = heightCm;
        this.dateOfBirth = dateOfBirth;
        this.activityLevel = activityLevel;
    }
}
```

**アノテーションの説明:**
| アノテーション | 意味 |
|-------------|------|
| `@Entity` | このクラスがDBテーブルに対応することを宣言 |
| `@Table(name = "users")` | 対応するテーブル名を指定 |
| `@Id` | 主キーであることを示す |
| `@GeneratedValue(strategy = GenerationType.UUID)` | UUIDを自動生成 |
| `@Column` | カラムの詳細設定（NULL可否、文字数制限など） |
| `@PrePersist` / `@PreUpdate` | INSERT/UPDATE 前に自動実行されるメソッド |

#### どう作るか（OAuthToken.java）

```java
package com.fitbitagent.domain.entity;

import jakarta.persistence.*;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import java.time.LocalDateTime;
import java.util.UUID;

@Entity
@Table(name = "oauth_tokens")
@Getter
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class OAuthToken {

    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    private UUID id;

    @OneToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id", nullable = false, unique = true)
    private User user;

    // 暗号化済みのアクセストークンを保存
    @Column(name = "access_token", nullable = false, length = 1024)
    private String accessToken;

    // 暗号化済みのリフレッシュトークンを保存
    @Column(name = "refresh_token", nullable = false, length = 1024)
    private String refreshToken;

    @Column(name = "expires_at", nullable = false)
    private LocalDateTime expiresAt;

    @Column(name = "scope", nullable = false)
    private String scope;

    // トークン更新用メソッド
    public void updateTokens(String encryptedAccessToken, String encryptedRefreshToken,
                              LocalDateTime expiresAt) {
        this.accessToken = encryptedAccessToken;
        this.refreshToken = encryptedRefreshToken;
        this.expiresAt = expiresAt;
    }
}
```

**`@OneToOne` とは?**
1人のユーザーに対して1つの oauth_token が対応することを表す。
`@JoinColumn(name = "user_id")` で oauth_tokens.user_id = users.id の外部キー関係を定義する。

**なぜそうするか:**
- docs/basic-functional-design.md §4.2 テーブル定義 の users / oauth_tokens テーブルに準拠
- アクセストークンはDBに平文で保存せず、暗号化済みの文字列を保存する（docs/architecture.md §6.2）

**確認方法:**
```bash
cd backend && mvn compile
```
コンパイルエラーがないことを確認する。

---

### Step 3: UserRepository.java / OAuthTokenRepository.java を作成する

#### 何を作るか

| ファイル | パッケージ | 役割 |
|---------|----------|------|
| `UserRepository.java` | `com.fitbitagent.repository` | usersテーブルへのDB操作インターフェース |
| `OAuthTokenRepository.java` | `com.fitbitagent.repository` | oauth_tokensテーブルへのDB操作インターフェース |

**Spring Data JPA の Repository とは?**
インターフェースを定義するだけで、Spring Boot が自動的に SQL を生成してくれる仕組み。
`JpaRepository<エンティティ型, 主キーの型>` を継承するだけで `save()`, `findById()`, `delete()` などが使える。

#### どう作るか（UserRepository.java）

```java
package com.fitbitagent.repository;

import com.fitbitagent.domain.entity.User;
import org.springframework.data.jpa.repository.JpaRepository;
import java.util.Optional;
import java.util.UUID;

public interface UserRepository extends JpaRepository<User, UUID> {

    // SELECT * FROM users WHERE fitbit_user_id = ? を自動生成する
    Optional<User> findByFitbitUserId(String fitbitUserId);
}
```

#### どう作るか（OAuthTokenRepository.java）

```java
package com.fitbitagent.repository;

import com.fitbitagent.domain.entity.OAuthToken;
import com.fitbitagent.domain.entity.User;
import org.springframework.data.jpa.repository.JpaRepository;
import java.util.Optional;
import java.util.UUID;

public interface OAuthTokenRepository extends JpaRepository<OAuthToken, UUID> {

    // SELECT * FROM oauth_tokens WHERE user_id = ? を自動生成する
    Optional<OAuthToken> findByUser(User user);
}
```

**なぜそうするか:**
- docs/architecture.md §3.2 パッケージ構成 の `repository/` パッケージに準拠
- メソッド名のルール: `findBy + フィールド名` で Spring Data JPA が自動的にSQLを生成する

**確認方法:**
```bash
cd backend && mvn compile
```
コンパイルエラーがないことを確認する。

---

### Step 4: TokenEncryptionService.java を作成する

#### 何を作るか

| ファイル | パッケージ | 役割 |
|---------|----------|------|
| `TokenEncryptionService.java` | `com.fitbitagent.service` | AES-256-GCM方式でトークンを暗号化・復号するサービス |

**なぜ暗号化が必要か?**
アクセストークンは Fitbit の個人データにアクセスできる「鍵」。
DBに平文で保存すると、DBが漏洩した場合に全ユーザーのFitbitデータが危険にさらされる。
AES-256-GCM は改ざん検知付きの強力な暗号化方式（docs/architecture.md §6.2）。

#### どう作るか

```java
package com.fitbitagent.service;

import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;

import javax.crypto.Cipher;
import javax.crypto.spec.GCMParameterSpec;
import javax.crypto.spec.SecretKeySpec;
import java.security.SecureRandom;
import java.util.Base64;

@Slf4j
@Service
public class TokenEncryptionService {

    private static final String ALGORITHM = "AES/GCM/NoPadding";
    private static final int GCM_IV_LENGTH = 12;   // 推奨値: 12バイト
    private static final int GCM_TAG_LENGTH = 128; // 認証タグ: 128ビット

    private final SecretKeySpec secretKey;

    public TokenEncryptionService(@Value("${token.encryption-key}") String encryptionKey) {
        // キーを32バイト（256ビット）に調整する
        byte[] keyBytes = encryptionKey.getBytes();
        byte[] key32 = new byte[32];
        System.arraycopy(keyBytes, 0, key32, 0, Math.min(keyBytes.length, 32));
        this.secretKey = new SecretKeySpec(key32, "AES");
    }

    /**
     * トークンを暗号化する。
     * 暗号化されたデータは "Base64(IV) + ":" + Base64(暗号文)" の形式で返す。
     */
    public String encrypt(String plainText) {
        try {
            // IVをランダムに生成（毎回異なるIVを使うことで安全性を確保）
            byte[] iv = new byte[GCM_IV_LENGTH];
            new SecureRandom().nextBytes(iv);

            Cipher cipher = Cipher.getInstance(ALGORITHM);
            cipher.init(Cipher.ENCRYPT_MODE, secretKey, new GCMParameterSpec(GCM_TAG_LENGTH, iv));
            byte[] encrypted = cipher.doFinal(plainText.getBytes());

            // IV と暗号文を連結してBase64エンコード
            String ivBase64 = Base64.getEncoder().encodeToString(iv);
            String encryptedBase64 = Base64.getEncoder().encodeToString(encrypted);
            return ivBase64 + ":" + encryptedBase64;
        } catch (Exception e) {
            throw new IllegalStateException("Failed to encrypt token", e);
        }
    }

    /**
     * 暗号化されたトークンを復号する。
     */
    public String decrypt(String encryptedText) {
        try {
            String[] parts = encryptedText.split(":");
            byte[] iv = Base64.getDecoder().decode(parts[0]);
            byte[] encrypted = Base64.getDecoder().decode(parts[1]);

            Cipher cipher = Cipher.getInstance(ALGORITHM);
            cipher.init(Cipher.DECRYPT_MODE, secretKey, new GCMParameterSpec(GCM_TAG_LENGTH, iv));
            byte[] decrypted = cipher.doFinal(encrypted);
            return new String(decrypted);
        } catch (Exception e) {
            throw new IllegalStateException("Failed to decrypt token", e);
        }
    }
}
```

**暗号化の仕組み（簡単に）:**
1. 毎回ランダムな「初期化ベクトル（IV）」を生成する（同じテキストでも毎回違う暗号文になる）
2. AES-256-GCMで暗号化する（改ざんがあるとエラーになる仕組み付き）
3. IV と暗号文を `:` で繋いでBase64でDBに保存する
4. 復号時は `:` で分割してIVと暗号文を取り出し、復号する

**なぜそうするか:**
- docs/architecture.md §6.2 AES-256-GCM暗号化方式の仕様に準拠

**確認方法:**
```bash
cd backend && mvn compile
```
コンパイルエラーがないことを確認する。

---

### Step 5: FitbitConfig.java / FitbitOAuthClient.java を作成する

#### 何を作るか

| ファイル | パッケージ | 役割 |
|---------|----------|------|
| `FitbitConfig.java` | `com.fitbitagent.config` | application.yml の `fitbit.*` 設定値を Java クラスとして保持する |
| `FitbitOAuthClient.java` | `com.fitbitagent.client.fitbit` | Fitbitのトークンエンドポイントを呼び出すHTTPクライアント |

#### どう作るか（FitbitConfig.java）

```java
package com.fitbitagent.config;

import lombok.Getter;
import lombok.Setter;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.context.annotation.Configuration;

@Configuration
@ConfigurationProperties(prefix = "fitbit")
@Getter
@Setter
public class FitbitConfig {

    private String clientId;
    private String clientSecret;
    private String tokenUri;
}
```

**`@ConfigurationProperties` とは?**
`application.yml` の設定値を自動的にフィールドに注入してくれるアノテーション。
`prefix = "fitbit"` を指定すると、`fitbit.client-id` → `clientId` フィールドに注入される。

#### どう作るか（FitbitOAuthClient.java）

まず、Fitbit トークンAPIのレスポンスを受け取るDTOを作成する。

**`FitbitTokenResponse.java`** (パッケージ: `com.fitbitagent.client.fitbit.dto`)
```java
package com.fitbitagent.client.fitbit.dto;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.Getter;

@Getter
public class FitbitTokenResponse {

    @JsonProperty("access_token")
    private String accessToken;

    @JsonProperty("refresh_token")
    private String refreshToken;

    @JsonProperty("expires_in")
    private int expiresIn; // 秒単位でのトークン有効期限

    @JsonProperty("token_type")
    private String tokenType;

    @JsonProperty("scope")
    private String scope;

    @JsonProperty("user_id")
    private String userId;
}
```

次に、リフレッシュを実行するクライアントクラスを作成する。

**`FitbitOAuthClient.java`** (パッケージ: `com.fitbitagent.client.fitbit`)
```java
package com.fitbitagent.client.fitbit;

import com.fitbitagent.client.fitbit.dto.FitbitTokenResponse;
import com.fitbitagent.config.FitbitConfig;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Component;
import org.springframework.util.LinkedMultiValueMap;
import org.springframework.util.MultiValueMap;
import org.springframework.web.reactive.function.BodyInserters;
import org.springframework.web.reactive.function.client.WebClient;

import java.util.Base64;

@Slf4j
@Component
@RequiredArgsConstructor
public class FitbitOAuthClient {

    private final FitbitConfig fitbitConfig;
    private final WebClient webClient = WebClient.create();

    /**
     * リフレッシュトークンを使って新しいアクセストークンを取得する。
     * docs/architecture.md §7.1 トークン自動リフレッシュ に基づく。
     *
     * @param refreshToken 平文（復号済み）のリフレッシュトークン
     * @return Fitbitから返された新しいトークン情報
     */
    public FitbitTokenResponse refreshAccessToken(String refreshToken) {
        log.info("Refreshing Fitbit access token");

        // Basic認証: client_id:client_secret をBase64エンコードしてヘッダーに付与
        String credentials = fitbitConfig.getClientId() + ":" + fitbitConfig.getClientSecret();
        String basicAuth = "Basic " + Base64.getEncoder().encodeToString(credentials.getBytes());

        MultiValueMap<String, String> body = new LinkedMultiValueMap<>();
        body.add("grant_type", "refresh_token");
        body.add("refresh_token", refreshToken);

        return webClient.post()
                .uri(fitbitConfig.getTokenUri())
                .header("Authorization", basicAuth)
                .contentType(MediaType.APPLICATION_FORM_URLENCODED)
                .body(BodyInserters.fromFormData(body))
                .retrieve()
                .bodyToMono(FitbitTokenResponse.class)
                .block(); // 同期的に結果を待つ
    }
}
```

**なぜそうするか:**
- docs/architecture.md §7.1 Fitbit APIクライアント設計 → トークン自動リフレッシュの仕様に準拠
- `WebClient` は `spring-boot-starter-webflux` が提供する非同期HTTPクライアント

**確認方法:**
```bash
cd backend && mvn compile
```
コンパイルエラーがないことを確認する。

---

### Step 6: AuthService.java / OAuth2AuthenticationSuccessHandler.java を作成する

#### 何を作るか

| ファイル | パッケージ | 役割 |
|---------|----------|------|
| `OAuth2AuthenticationSuccessHandler.java` | `com.fitbitagent.service` | OAuth2認証成功時に呼ばれるハンドラー |
| `AuthService.java` | `com.fitbitagent.service` | OAuth2成功後の処理（ユーザー保存・トークン暗号化）とログアウト処理 |

**OAuth2認証成功の流れ:**
1. ユーザーがFitbitで認証し、`/api/auth/callback` にリダイレクトされる
2. Spring Security がコードをトークンに交換する（自動）
3. `OAuth2AuthenticationSuccessHandler.onAuthenticationSuccess()` が呼ばれる
4. `AuthService.handleOAuth2Success()` でトークン暗号化・ユーザー保存を行う
5. `/dashboard` にリダイレクトする

#### どう作るか（AuthService.java）

```java
package com.fitbitagent.service;

import com.fitbitagent.domain.entity.OAuthToken;
import com.fitbitagent.domain.entity.User;
import com.fitbitagent.repository.OAuthTokenRepository;
import com.fitbitagent.repository.UserRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.security.oauth2.client.OAuth2AuthorizedClient;
import org.springframework.security.oauth2.core.user.OAuth2User;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.time.ZoneId;
import java.util.Map;

@Slf4j
@Service
@RequiredArgsConstructor
public class AuthService {

    private final UserRepository userRepository;
    private final OAuthTokenRepository oAuthTokenRepository;
    private final TokenEncryptionService tokenEncryptionService;

    /**
     * OAuth2認証成功時の処理。
     * ユーザーを作成/更新し、暗号化したトークンをDBに保存する。
     *
     * @param oauth2User    Fitbitから取得したユーザー情報
     * @param authorizedClient トークン情報が含まれるオブジェクト
     * @return 保存したUserエンティティ
     */
    @Transactional
    public User handleOAuth2Success(OAuth2User oauth2User, OAuth2AuthorizedClient authorizedClient) {
        // Fitbit profile APIのレスポンスはネストされているため、"user" キーを取り出す
        Map<String, Object> fitbitUser = oauth2User.getAttribute("user");
        if (fitbitUser == null) {
            throw new IllegalStateException("Fitbit user profile not found in OAuth2 response");
        }

        String fitbitUserId = (String) fitbitUser.get("encodedId");
        String displayName = (String) fitbitUser.get("displayName");
        String gender = (String) fitbitUser.get("gender");

        log.info("OAuth2 login success: fitbitUserId={}", fitbitUserId);

        // ユーザーを作成または更新する（初回ログイン: 新規作成 / 2回目以降: 更新）
        User user = userRepository.findByFitbitUserId(fitbitUserId)
                .orElse(User.builder()
                        .fitbitUserId(fitbitUserId)
                        .build());

        user.updateProfile(displayName, gender, null, null, null);
        user = userRepository.save(user);

        // アクセストークンとリフレッシュトークンを暗号化してDBに保存する
        String encryptedAccessToken = tokenEncryptionService.encrypt(
                authorizedClient.getAccessToken().getTokenValue());

        // リフレッシュトークンの取得（nullの場合はスキップ）
        String refreshTokenValue = authorizedClient.getRefreshToken() != null
                ? authorizedClient.getRefreshToken().getTokenValue()
                : "";
        String encryptedRefreshToken = tokenEncryptionService.encrypt(refreshTokenValue);

        // トークンの有効期限を計算する
        LocalDateTime expiresAt = authorizedClient.getAccessToken().getExpiresAt() != null
                ? LocalDateTime.ofInstant(authorizedClient.getAccessToken().getExpiresAt(), ZoneId.systemDefault())
                : LocalDateTime.now().plusHours(8); // Fitbitのデフォルト有効期限

        // oauth_tokensテーブルにupsert（存在すれば更新、なければ作成）
        final User savedUser = user;
        OAuthToken oAuthToken = oAuthTokenRepository.findByUser(savedUser)
                .orElse(OAuthToken.builder()
                        .user(savedUser)
                        .build());

        oAuthToken.updateTokens(encryptedAccessToken, encryptedRefreshToken, expiresAt);

        // scopeが未設定の場合は初回のscope情報を設定（Builderで設定できないためreflectionを使わずに別途処理）
        if (oAuthToken.getScope() == null) {
            oAuthToken = OAuthToken.builder()
                    .user(savedUser)
                    .accessToken(encryptedAccessToken)
                    .refreshToken(encryptedRefreshToken)
                    .expiresAt(expiresAt)
                    .scope(authorizedClient.getAccessToken().getScopes().toString())
                    .build();
        }

        oAuthTokenRepository.save(oAuthToken);

        return savedUser;
    }
}
```

**`@Transactional` とは?**
このメソッド内のDB操作（save）が途中で失敗した場合、すべてロールバック（取り消し）される。
ユーザー保存は成功してトークン保存は失敗、という中途半端な状態になるのを防ぐ。

#### どう作るか（OAuth2AuthenticationSuccessHandler.java）

```java
package com.fitbitagent.service;

import com.fitbitagent.domain.entity.User;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import jakarta.servlet.http.HttpSession;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.security.core.Authentication;
import org.springframework.security.oauth2.client.OAuth2AuthorizedClient;
import org.springframework.security.oauth2.client.OAuth2AuthorizedClientService;
import org.springframework.security.oauth2.client.authentication.OAuth2AuthenticationToken;
import org.springframework.security.web.authentication.AuthenticationSuccessHandler;
import org.springframework.stereotype.Component;

import java.io.IOException;

@Slf4j
@Component
@RequiredArgsConstructor
public class OAuth2AuthenticationSuccessHandler implements AuthenticationSuccessHandler {

    private final AuthService authService;
    private final OAuth2AuthorizedClientService authorizedClientService;

    @Override
    public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response,
                                        Authentication authentication) throws IOException {
        OAuth2AuthenticationToken oauthToken = (OAuth2AuthenticationToken) authentication;

        // Spring Security が管理しているトークン情報を取得する
        OAuth2AuthorizedClient authorizedClient = authorizedClientService.loadAuthorizedClient(
                oauthToken.getAuthorizedClientRegistrationId(), // "fitbit"
                oauthToken.getName());

        // ユーザー保存・トークン暗号化処理
        User user = authService.handleOAuth2Success(oauthToken.getPrincipal(), authorizedClient);

        // セッションにユーザーIDを保存する
        HttpSession session = request.getSession(true);
        session.setAttribute("userId", user.getId().toString());

        log.info("OAuth2 login completed. userId={}, redirecting to /dashboard", user.getId());

        // ダッシュボードにリダイレクト
        response.sendRedirect("/dashboard");
    }
}
```

**なぜそうするか:**
- docs/architecture.md §6.1 OAuth2.0認証フロー詳細 の「HTTPセッション生成」「DB保存」ステップに対応
- docs/basic-functional-design.md §6.2 OAuth2.0 ログインフローに基づく

**確認方法:**
```bash
cd backend && mvn compile
```
コンパイルエラーがないことを確認する。

---

### Step 7: AuthController.java / SecurityConfig.java / WebConfig.java を作成する

#### 何を作るか

| ファイル | パッケージ | 役割 |
|---------|----------|------|
| `AuthController.java` | `com.fitbitagent.controller` | `/api/auth/login` と `/api/auth/logout` エンドポイント |
| `SecurityConfig.java` | `com.fitbitagent.config` | Spring Security の全体設定（OAuth2・CORS・CSRF・セッション） |
| `WebConfig.java` | `com.fitbitagent.config` | CORS の詳細設定 |

#### どう作るか（AuthController.java）

```java
package com.fitbitagent.controller;

import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.web.bind.annotation.*;

import java.io.IOException;

@Slf4j
@RestController
@RequestMapping("/api/auth")
@RequiredArgsConstructor
public class AuthController {

    /**
     * Fitbit OAuth2.0 ログイン開始。
     * Spring Security の OAuth2 認可エンドポイント（/api/auth/login/fitbit）にリダイレクトする。
     * フロントエンドはこのURLにナビゲートするだけでよい。
     */
    @GetMapping("/login")
    public void login(HttpServletResponse response) throws IOException {
        // Spring Security が "/api/auth/login/{registrationId}" を処理する
        // "/api/auth/login" → "/api/auth/login/fitbit" に転送する
        response.sendRedirect("/api/auth/login/fitbit");
    }

    /**
     * ログアウト処理。
     * セッションを破棄し、ログイン画面にリダイレクトする。
     * docs/architecture.md §6.3 セッション管理に基づく。
     */
    @PostMapping("/logout")
    public ResponseEntity<Void> logout(HttpServletRequest request) {
        // セッションを無効化する
        var session = request.getSession(false);
        if (session != null) {
            session.invalidate();
        }
        // Spring Security のセキュリティコンテキストをクリアする
        SecurityContextHolder.clearContext();
        log.info("User logged out");
        return ResponseEntity.ok().build();
    }
}
```

#### どう作るか（SecurityConfig.java）

```java
package com.fitbitagent.config;

import com.fitbitagent.service.OAuth2AuthenticationSuccessHandler;
import lombok.RequiredArgsConstructor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.HttpMethod;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.csrf.CookieCsrfTokenRepository;
import org.springframework.security.web.csrf.CsrfTokenRequestAttributeHandler;

@Configuration
@EnableWebSecurity
@RequiredArgsConstructor
public class SecurityConfig {

    private final OAuth2AuthenticationSuccessHandler successHandler;

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            // CSRF設定: Cookie経由でトークンを受け渡す方式（docs/architecture.md §6.5）
            .csrf(csrf -> csrf
                .csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse())
                .csrfTokenRequestHandler(new CsrfTokenRequestAttributeHandler())
                // OAuth2コールバックはCSRFから除外する（stateパラメータがCSRF代わり）
                .ignoringRequestMatchers("/api/auth/callback")
            )

            // アクセス制御: どのURLに誰がアクセスできるか
            .authorizeHttpRequests(auth -> auth
                // 認証不要なURL
                .requestMatchers("/api/auth/login", "/api/auth/login/**",
                                 "/api/auth/callback", "/api/auth/callback/**").permitAll()
                // その他のAPIは認証が必要
                .requestMatchers("/api/**").authenticated()
                // フロントエンドのルーティング（React SPA）は認証不要
                .anyRequest().permitAll()
            )

            // OAuth2 Login 設定
            .oauth2Login(oauth2 -> oauth2
                // ログイン開始URLを /api/auth/login/{registrationId} に変更
                .authorizationEndpoint(auth -> auth
                    .baseUri("/api/auth/login"))
                // コールバックURLを /api/auth/callback に変更
                .redirectionEndpoint(redirect -> redirect
                    .baseUri("/api/auth/callback"))
                // 認証成功時のハンドラーを指定
                .successHandler(successHandler)
            )

            // セッション設定（docs/architecture.md §6.3）
            .sessionManagement(session -> session
                .invalidSessionUrl("/login")
            );

        return http.build();
    }
}
```

#### どう作るか（WebConfig.java）

```java
package com.fitbitagent.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.CorsRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class WebConfig implements WebMvcConfigurer {

    /**
     * CORS設定（docs/architecture.md §6.4）
     * フロントエンド（localhost:5173）からのリクエストを許可する。
     */
    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/api/**")
                .allowedOrigins(
                    "http://localhost:5173",    // Vite開発サーバー
                    "http://localhost:3000"     // 予備
                )
                .allowedMethods("GET", "POST", "PUT", "DELETE")
                .allowedHeaders("Content-Type", "X-CSRF-TOKEN")
                .allowCredentials(true); // Cookie（セッション）を送受信するために必要
    }
}
```

**なぜそうするか:**
- docs/architecture.md §6.1〜6.5 セキュリティ設計の全項目に基づく
- `CookieCsrfTokenRepository.withHttpOnlyFalse()` → フロントエンドが JavaScript で CSRF トークンを読めるようにする

**確認方法:**
```bash
# Docker Compose でDBを起動してから
docker compose -f docker/docker-compose.yml up -d db

# アプリを起動する
cd backend && SPRING_PROFILES_ACTIVE=dev mvn spring-boot:run

# ブラウザで以下にアクセスしてFitbitにリダイレクトされることを確認
# http://localhost:8080/api/auth/login
```

---

## 作業完了後の確認

全 Step 完了後、以下の受入条件をテストする。

| # | テスト内容 | 期待結果 |
|---|----------|---------|
| 1 | `http://localhost:8080/api/auth/login` にブラウザでアクセス | Fitbitのログイン画面にリダイレクトされる |
| 2 | Fitbitでログイン後 | `/dashboard` にリダイレクトされる |
| 3 | PostgreSQLで `SELECT * FROM users;` を実行 | ユーザーレコードが1件作成されている |
| 4 | PostgreSQLで `SELECT * FROM oauth_tokens;` を実行 | トークンが暗号化（判読不能な文字列）で保存されている |
| 5 | `POST /api/auth/logout` をcurlで実行 | 200 OK が返り、以降の認証済みAPIが 401 になる |

---

## 詰まったら

- エンティティとテーブルのカラム定義が一致しているか確認する（V1, V2マイグレーションファイルを参照）
- `mvn compile` でコンパイルエラーを確認する
- Spring Security のログが出ていない場合は `logging.level.org.springframework.security: DEBUG` を application-dev.yml に追加する
- 不明な点はいつでも質問してください
